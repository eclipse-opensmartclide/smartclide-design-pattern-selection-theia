{"version":3,"sources":["webpack://browser-app/../node_modules/@theia/core/shared/@theia/application-package/lib/environment.js","webpack://browser-app/../node_modules/@theia/filesystem/src/browser/file-service.ts","webpack://browser-app/../node_modules/@theia/filesystem/src/browser/filesystem-preferences.ts","webpack://browser-app/../node_modules/@theia/filesystem/src/browser/filesystem-watcher-error-handler.ts","webpack://browser-app/../node_modules/@theia/filesystem/src/common/delegating-file-system-provider.ts","webpack://browser-app/../node_modules/@theia/filesystem/src/common/files.ts","webpack://browser-app/../node_modules/@theia/filesystem/src/common/filesystem-utils.ts","webpack://browser-app/../node_modules/@theia/filesystem/src/common/io.ts"],"names":[],"mappings":";;;;;;;;AAAA,gLAAsE;;;;;;;;;;;;;ACAtE;;;;;;;;;;;;;;kFAckF;AAClF;;;gGAGgG;AAChG,yIAAyI;AACzI,sJAAsJ;AACtJ,qKAAqK;AACrK,+JAA+J;AAC/J,4KAA4K;;;;;;;;;;;;AAE5K,4BAA4B;AAC5B,iDAAiD;AACjD,oCAAoC;AACpC,qDAAqD;AACrD,uDAAuD;AAEvD,+HAAwF;AAExF,gJAAwE;AACxE,gJAAiG;AACjG,0IAAqF;AACrF,2HAAqF;AACrF,2KAAoF;AACpF,qKAA+E;AAC/E,oHAeyB;AACzB,8HAAgL;AAChL,8HAAyK;AACzK,wJAAuE;AACvE,gKAAiE;AACjE,4JAA0E;AAC1E,kMAAyF;AAEzF,iKAA6E;AAC7E,uIAAuE;AACvE,4JAAgH;AAEhH,2GAAkD;AAClD,8LAAmF;AACnF,qJAA6D;AA4GhD,+BAAuB,GAAG,MAAM,CAAC,yBAAyB,CAAC,CAAC;AA0EzE,MAAa,sBAAuB,SAAQ,0BAAkB;IAE1D,YACI,OAAe,EACR,uBAAgD,EAChD,OAAoD;QAE3D,KAAK,CAAC,OAAO,4BAAuC,CAAC;QAH9C,4BAAuB,GAAvB,uBAAuB,CAAyB;QAChD,YAAO,GAAP,OAAO,CAA6C;QAG3D,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,sBAAsB,CAAC,SAAS,CAAC,CAAC;IAClE,CAAC;CAEJ;AAXD,wDAWC;AAED;;;;;GAKG;AAEH,IAAa,WAAW,GAAxB,MAAa,WAAW;IAAxB;QAEqB,gBAAW,GAAG,EAAE,GAAG,IAAI,CAAC;QA8BzC,iBAAiB;QAET,mBAAc,GAAG,CAAC,CAAC;QAEV,kCAA6B,GAAG,IAAI,oBAAY,EAA0B,CAAC;QAC5F;;;WAGG;QACM,2BAAsB,GAAG,IAAI,CAAC,6BAA6B,CAAC,KAAK,CAAC;QAE1D,kCAA6B,GAAG,IAAI,oBAAY,EAA0B,CAAC;QAC5F;;;WAGG;QACM,2BAAsB,GAAG,IAAI,CAAC,6BAA6B,CAAC,KAAK,CAAC;QAE1D,iCAA4B,GAAG,IAAI,oBAAY,EAA0B,CAAC;QAC3F;;;WAGG;QACM,0BAAqB,GAAG,IAAI,CAAC,4BAA4B,CAAC,KAAK,CAAC;QAEzE,aAAa;QAEb,+BAA+B;QAEvB,sDAAiD,GAAG,IAAI,eAAO,EAAuC,CAAC;QACtG,+CAA0C,GAAG,IAAI,CAAC,iDAAiD,CAAC,KAAK,CAAC;QAE3G,4CAAuC,GAAG,IAAI,eAAO,EAAqC,CAAC;QACnG;;WAEG;QACM,qCAAgC,GAAG,IAAI,CAAC,uCAAuC,CAAC,KAAK,CAAC;QAEvF,qDAAgD,GAAG,IAAI,eAAO,EAA6C,CAAC;QAC3G,8CAAyC,GAAG,IAAI,CAAC,gDAAgD,CAAC,KAAK,CAAC;QAEhG,cAAS,GAAG,IAAI,GAAG,EAA8B,CAAC;QAClD,gBAAW,GAAG,IAAI,GAAG,EAAuC,CAAC;QA+G9E,aAAa;QAEL,6BAAwB,GAAG,IAAI,eAAO,EAAsB,CAAC;QACrE;;;WAGG;QACM,sBAAiB,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC;QAu4BjE,aAAa;QAEb,wBAAwB;QAEhB,4BAAuB,GAAG,IAAI,eAAO,EAAoB,CAAC;QAClE;;WAEG;QACM,qBAAgB,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC;QAEvD,mBAAc,GAAG,IAAI,GAAG,EAAqD,CAAC;QA2DtF,aAAa;QAEb,kBAAkB;QAEV,gBAAW,GAA+B,IAAI,GAAG,EAAE,CAAC;QAoO5D,aAAa;QAEb,sCAAsC;QAErB,iBAAY,GAA+B,EAAE,CAAC;IA8GnE,CAAC;IA58Ca,IAAI;QACV,KAAK,MAAM,YAAY,IAAI,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,EAAE;YAC9D,YAAY,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;SAClD;IACL,CAAC;IA8CD;;;;;;OAMG;IACH,gBAAgB,CAAC,MAAc,EAAE,QAA4B;QACzD,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,yCAAyC,MAAM,0BAA0B,CAAC,CAAC;SAC9F;QAED,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QACrC,IAAI,CAAC,iDAAiD,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC;QAE/F,MAAM,mBAAmB,GAAG,IAAI,iCAAoB,EAAE,CAAC;QACvD,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,IAAI,wBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAChI,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC;QACvF,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,gDAAgD,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;QAEnJ,OAAO,uBAAU,CAAC,MAAM,CAAC,GAAG,EAAE;YAC1B,IAAI,CAAC,iDAAiD,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC;YAChG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAE9B,mBAAmB,CAAC,OAAO,EAAE,CAAC;QAClC,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,gBAAgB,CAAC,MAAc;QACjC,IAAI,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC1C,IAAI,QAAQ,EAAE;YACV,OAAO,QAAQ,CAAC;SACnB;QACD,IAAI,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC9C,IAAI,CAAC,UAAU,EAAE;YACb,MAAM,kBAAkB,GAAG,IAAI,uBAAQ,EAAsB,CAAC;YAC9D,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,GAAG,kBAAkB,CAAC,OAAO,CAAC,CAAC;YACtE,sBAAc,CAAC,IAAI,CAAC,IAAI,CAAC,uCAAuC,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;gBACpF,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACtC,IAAI,CAAC,QAAQ,EAAE;oBACX,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;oBAC1B,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC;oBACtB,KAAK,CAAC,OAAO,GAAG,4CAA4C,MAAM,EAAE,CAAC;oBACrE,MAAM,KAAK,CAAC;iBACf;qBAAM;oBACH,kBAAkB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;iBACxC;YACL,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;SAC/C;QACD,OAAO,UAAU,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACH,iBAAiB,CAAC,QAAa;QAC3B,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED;;;;;;OAMG;IACH,aAAa,CAAC,QAAa,EAAE,UAA0C;QACnE,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAErD,OAAO,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,YAAY,GAAG,UAAU,CAAC,CAAC,CAAC;IAChE,CAAC;IAES,KAAK,CAAC,YAAY,CAAC,QAAa;QACtC,0BAA0B;QAC1B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,EAAE;YAC3B,MAAM,IAAI,0BAAkB,CAAC,iEAAiE,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE,4BAAwC,CAAC;SAC3K;QAED,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IAClD,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,QAAa;QACxC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,IAAI,uCAA+B,CAAC,QAAQ,CAAC,IAAI,8BAAsB,CAAC,QAAQ,CAAC,EAAE;YAC/E,OAAO,QAAQ,CAAC;SACnB;QAED,MAAM,IAAI,KAAK,CAAC,mCAAmC,QAAQ,CAAC,MAAM,2HAA2H,CAAC,CAAC;IACnM,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAAa;QACzC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACnD,IAAI,uCAA+B,CAAC,QAAQ,CAAC,IAAI,8BAAsB,CAAC,QAAQ,CAAC,EAAE;YAC/E,OAAO,QAAQ,CAAC;SACnB;QAED,MAAM,IAAI,KAAK,CAAC,mCAAmC,QAAQ,CAAC,MAAM,4GAA4G,CAAC,CAAC;IACpL,CAAC;IAoBD,KAAK,CAAC,OAAO,CAAC,QAAa,EAAE,OAAa;QACtC,IAAI;YACA,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SACtD;QAAC,OAAO,KAAK,EAAE;YAEZ,gEAAgE;YAChE,IAAI,qCAA6B,CAAC,KAAK,CAAC,KAAK,mCAA2B,CAAC,YAAY,EAAE;gBACnF,MAAM,IAAI,0BAAkB,CAAC,wCAAwC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,GAAG,yBAAqC,CAAC;aAChJ;YAED,kCAAkC;YAClC,MAAM,qCAA6B,CAAC,KAAK,CAAC,CAAC;SAC9C;IACL,CAAC;IAIO,KAAK,CAAC,aAAa,CAAC,QAAa,EAAE,OAA4B;QACnE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,MAAM,SAAS,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAC;QACrC,MAAM,6BAA6B,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,6BAA6B,CAAC;QAC7E,MAAM,eAAe,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,CAAC;QAEjD,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE3C,IAAI,IAAiD,CAAC;QAEtD,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE;YAE9F,6CAA6C;YAC7C,IAAI,CAAC,IAAI,EAAE;gBACP,IAAI,GAAG,uCAAiB,CAAC,OAAO,CAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,+BAAmD,CAAC,CAAC,CAAC;gBACrH,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;gBACzB,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,MAAM,EAAE;oBAC9C,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,IAAK,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;iBAClD;aACJ;YAED,gCAAgC;YAChC,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE;gBACtE,OAAO,IAAI,CAAC;aACf;YAED,2CAA2C;YAC3C,IAAI,IAAI,CAAC,WAAW,IAAI,6BAA6B,EAAE;gBACnD,OAAO,QAAQ,KAAK,CAAC,CAAC;aACzB;YAED,OAAO,KAAK,CAAC;QACjB,CAAC,CAAC,CAAC;IACP,CAAC;IAIO,KAAK,CAAC,UAAU,CAAC,QAA4B,EAAE,QAAa,EAAE,IAA+C,EAAE,QAA4B,EAAE,eAAwB,EAAE,OAAuD;QAClO,MAAM,QAAQ,GAAG,gBAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAEnD,mCAAmC;QACnC,IAAI,QAAQ,CAAC,WAAW,IAAI,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE;YACrD,IAAI;gBACA,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;gBACjD,MAAM,eAAe,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE;oBACzE,IAAI;wBACA,MAAM,aAAa,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;wBAC7C,MAAM,SAAS,GAAG,eAAe,CAAC,CAAC,CAAC,MAAM,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC;wBAElF,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,aAAa,EAAE,SAAS,EAAE,OAAO,CAAC,MAAM,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;qBAC9G;oBAAC,OAAO,KAAK,EAAE;wBACZ,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;wBAErB,OAAO,IAAI,CAAC,CAAC,2CAA2C;qBAC3D;gBACL,CAAC,CAAC,CAAC,CAAC;gBAEJ,0FAA0F;gBAC1F,QAAQ,CAAC,QAAQ,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAe,CAAC;aACtE;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBAErB,QAAQ,CAAC,QAAQ,GAAG,EAAE,CAAC,CAAC,gEAAgE;aAC3F;YAED,OAAO,QAAQ,CAAC;SACnB;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAWD,KAAK,CAAC,UAAU,CAAC,SAA6D;QAC1E,OAAO,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,EAAC,KAAK,EAAC,EAAE;YAC3C,IAAI;gBACA,OAAO,EAAE,IAAI,EAAE,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;aAC3F;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBAErB,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC;aAC9C;QACL,CAAC,CAAC,CAAC,CAAC;IACR,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,MAAM,CAAC,QAAa;QACtB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,IAAI;YACA,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE3C,OAAO,CAAC,CAAC,IAAI,CAAC;SACjB;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,KAAK,CAAC;SAChB;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,IAAa;QACrC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,IAAI,CAAC,2BAAmB,CAAC,QAAQ,CAAC,EAAE;YAChC,OAAO,KAAK,CAAC;SAChB;QACD,IAAI;YACA,MAAM,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YACtC,OAAO,IAAI,CAAC;SACf;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,KAAK,CAAC;SAChB;IACL,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,MAAM,CAAC,QAAa;QACtB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,IAAI,CAAC,2BAAmB,CAAC,QAAQ,CAAC,EAAE;YAChC,OAAO,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;SACnC;QACD,OAAO,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED,oCAAoC;IAEpC,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,KAAiC,EAAE,OAA+B;QAC1F,IAAI,QAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAClD;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,QAAQ,EAAE,SAAS,iBAAuB,CAAC;QAEnF,MAAM,KAAK,GAAG,EAAE,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,gBAAsB,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC;QAC1G,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAErD,IAAI,IAA0B,CAAC;QAC/B,IAAI;YACA,IAAI,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACxD;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEpD,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,KAAK,CAAC,QAAQ,CAAC,QAAa,EAAE,KAAiC,EAAE,OAA+B;QACtG,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAChE,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACzE,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,QAAa,EAAE,KAAgC,EAAE,OAA8B;QACvF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAChE,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACzE,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE,EAAE,QAAQ,EAAE,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC5G,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,QAAa,EAAE,OAA6B;QACnD,MAAM,CAAC,YAAY,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,kCACnD,OAAO;YACV,uDAAuD;YACvD,wDAAwD;YACxD,qDAAqD;YACrD,mDAAmD;YACnD,sBAAsB;YACtB,gBAAgB,EAAE,IAAI,IACxB,CAAC;QAEH,uCACO,YAAY,KACf,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,QAAQ,IAAI,gBAAI,EAC3C,KAAK,EAAE,MAAM,sBAAa,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IACzE;IACN,CAAC;IAED,KAAK,CAAC,UAAU,CAAC,QAAa,EAAE,OAA6B;QACzD,MAAM,CAAC,YAAY,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAErE,uCACO,YAAY,KACf,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,QAAQ,IAAI,gBAAI,EAC3C,KAAK,EAAE,OAAO,CAAC,MAAM,IACvB;IACN,CAAC;IAEO,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,OAA8D;QAC9F,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QAE3C,kDAAkD;QAClD,IAAI,YAA+B,CAAC;QACpC,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,EAAE;YAC3B,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACvD,YAAY,mCACL,OAAO,KACV,KAAK,EAAE,mCAA0B,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,GAC9D,CAAC;SACL;aAAM;YACH,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SAC/D;QAED,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,YAAY,CAAC,KAAK,EAAE;YACxE,aAAa,EAAE,OAAO,CAAC,iBAAiB;YACxC,iBAAiB,EAAE,gBAAgB,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,OAAO,EAAE,gBAAgB,CAAC;SACnG,CAAC,CAAC;QAEH,kBAAkB;QAClB,IAAI,QAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,cAAc,KAAI,OAAO,CAAC,QAAQ,CAAC,WAAW,EAAE;YACzD,MAAM,IAAI,sBAAsB,CAAC,sDAAsD,0BAA0C,OAAO,CAAC,CAAC;SAC7I;QAED,OAAO,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;IACnC,CAAC;IAES,kBAAkB,CAAC,OAA6B;QACtD,OAAO,mCACA,OAAO,KACV,iBAAiB,EAAE,QAAO,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB,MAAK,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,yBAAyB,CAAC,GAC/I,CAAC;QACF,MAAM,MAAM,GAA2C,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC;QAC7F,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,EAAE;YACjC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,qBAAqB,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;SACvE;QACD,OAAO,OAAO,CAAC;IACnB,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,OAAyC,EAAE,OAA8B;QACjG,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QACpG,IAAI;YACA,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YAC1D,IAAI,2BAAmB,CAAC,QAAQ,CAAC,EAAE;gBAC/B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;gBAAA,CAAC;gBACtG,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE;oBACtD,YAAY,EAAE,OAAO,CAAC,YAAY;oBAClC,aAAa,EAAE,QAAQ;oBACvB,iBAAiB,EAAE,OAAO,CAAC,iBAAiB,IAAI,KAAK;iBACxD,CAAC,CAAC;gBACH,OAAO,MAAM,CAAC,MAAM,CAAC,gBAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;aACxF;iBAAM;gBACH,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;aAC/D;SACJ;QAAC,OAAO,KAAK,EAAE;YACZ,IAAI,CAAC,2BAA2B,CAAC,sBAAsB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACtF;IACL,CAAC;IAED,aAAa;IAEb,+BAA+B;IAE/B,KAAK,CAAC,UAAU,CAAC,QAAa,EAAE,2BAA6F,qBAAY,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,OAA2B;QAEjL,qBAAqB;QACrB,IAAI,EAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,KAAI,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;YACpD,MAAM,IAAI,0BAAkB,CAAC,0BAA0B,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,sDAAsD,+BAA2C,OAAO,CAAC,CAAC;SACnM;QAED,+CAA+C;QAC/C,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,wBAAwB,CAAC,CAAC;QAE1E,SAAS;QACT,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,0BAAkB,CAAC,QAAQ,kBAAwB,QAAQ,CAAC,CAAC,CAAC;QAErG,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,QAAa,EAAE,wBAA0F,EAAE,OAA0B;QACjJ,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QAEpG,IAAI;YAEA,iBAAiB;YACjB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YAEvE,8BAA8B;YAC9B,IAAI,CAAC,IAAI,EAAE;gBACP,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;aAChD;YAED,6EAA6E;YAC7E,8EAA8E;YAC9E,8EAA8E;YAC9E,iCAAiC;YACjC,IAAI,wCAA+I,CAAC;YACpJ,IAAI,8BAAsB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,wBAAwB,YAAY,qBAAY,CAAC,EAAE;gBACzF,IAAI,yBAAgB,CAAC,wBAAwB,CAAC,EAAE;oBAC5C,MAAM,cAAc,GAAG,MAAM,mBAAU,CAAC,wBAAwB,EAAE,CAAC,CAAC,CAAC;oBACrE,IAAI,cAAc,CAAC,KAAK,EAAE;wBACtB,wCAAwC,GAAG,qBAAY,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;qBACzF;yBAAM;wBACH,wCAAwC,GAAG,cAAc,CAAC;qBAC7D;iBACJ;qBAAM;oBACH,wCAAwC,GAAG,qBAAY,CAAC,wBAAwB,EAAE,IAAI,CAAC,EAAE,CAAC,qBAAY,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;iBAC3H;aACJ;iBAAM;gBACH,wCAAwC,GAAG,wBAAwB,CAAC;aACvE;YAED,+GAA+G;YAC/G,IAAI,CAAC,uCAA+B,CAAC,QAAQ,CAAC,IAAI,CAAC,8BAAsB,CAAC,QAAQ,CAAC,IAAI,wCAAwC,YAAY,qBAAY,CAAC,EAAE;gBACtJ,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,EAAE,wCAAwC,CAAC,CAAC;aAC9F;YAED,uBAAuB;iBAClB;gBACD,MAAM,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,wCAAwC,YAAY,qBAAY,CAAC,CAAC,CAAC,6BAAoB,CAAC,UAAU,CAAC,wCAAwC,CAAC,CAAC,CAAC,CAAC,wCAAwC,CAAC,CAAC;aAC3O;SACJ;QAAC,OAAO,KAAK,EAAE;YACZ,IAAI,CAAC,2BAA2B,CAAC,sBAAsB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACtF;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;IAC7D,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAA4B,EAAE,QAAa,EAAE,OAA0B;QACnG,IAAI,IAAI,GAAqB,SAAS,CAAC;QACvC,IAAI;YACA,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SACxC;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,SAAS,CAAC,CAAC,uBAAuB;SAC5C;QAED,2BAA2B;QAC3B,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,gBAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;YACxC,MAAM,IAAI,0BAAkB,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,+BAA+B,6BAAyC,OAAO,CAAC,CAAC;SACxK;QAED,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE;YACnC,MAAM,IAAI,0BAAkB,CAAC,qBAAqB,+BAA2C,OAAO,CAAC,CAAC;SACzG;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;;;;;;;OAaG;IACO,aAAa,CAAC,IAAU,EAAE,OAA0B;QAC1D,OAAO,CAAC,CAAC,OAAO,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,KAAK,qBAAa;YACvH,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ;YAC/D,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC,IAAI,KAAK,YAAI,CAAC,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,kDAAkD,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;IAC1J,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,QAAa,EAAE,OAAyB;QACnD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAEvD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,kCACxD,OAAO;YACV,uDAAuD;YACvD,wDAAwD;YACxD,qDAAqD;YACrD,mDAAmD;YACnD,sBAAsB;YACtB,gBAAgB,EAAE,IAAI,IACxB,CAAC;QAEH,uCACO,MAAM,KACT,KAAK,EAAE,MAAM,mCAA0B,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,IAChE;IACN,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,QAAa,EAAE,OAAyB;QACzD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAEvD,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAChE,CAAC;IAEO,KAAK,CAAC,kBAAkB,CAAC,QAA4G,EAAE,QAAa,EAAE,OAA0D;QAEpN,mDAAmD;QACnD,mDAAmD;QACnD,mDAAmD;QACnD,mDAAmD;QACnD,MAAM,iBAAiB,GAAG,IAAI,sCAAuB,EAAE,CAAC;QAExD,0BAA0B;QAC1B,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;YACpF,iBAAiB,CAAC,MAAM,EAAE,CAAC;YAE3B,MAAM,KAAK,CAAC;QAChB,CAAC,CAAC,CAAC;QAEH,IAAI;YAEA,iEAAiE;YACjE,gEAAgE;YAChE,+DAA+D;YAC/D,+BAA+B;YAC/B,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,KAAK,qBAAa,EAAE;gBAC/E,MAAM,WAAW,CAAC;aACrB;YAED,IAAI,iBAAsD,CAAC;YAE3D,8FAA8F;YAC9F,IAAI,CAAC,CAAC,uCAA+B,CAAC,QAAQ,CAAC,IAAI,mCAA2B,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,8BAAsB,CAAC,QAAQ,CAAC,KAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,EAAC,EAAE;gBAC1J,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;aAC5E;YAED,6DAA6D;iBACxD,IAAI,mCAA2B,CAAC,QAAQ,CAAC,EAAE;gBAC5C,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;aACpH;YAED,gBAAgB;iBACX;gBACD,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;aACpH;YAED,MAAM,CAAC,QAAQ,EAAE,UAAU,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,iBAAiB,CAAC,CAAC,CAAC;YAEnF,uCACO,QAAQ,KACX,KAAK,EAAE,UAAU,IACnB;SACL;QAAC,OAAO,KAAK,EAAE;YACZ,IAAI,CAAC,2BAA2B,CAAC,qBAAqB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACrF;IACL,CAAC;IAEO,gBAAgB,CAAC,QAAwD,EAAE,QAAa,EAAE,KAAwB,EAAE,UAA2B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QACtK,MAAM,UAAU,GAAG,QAAQ,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QAErE,OAAO,kBAAS,CAAC,UAAU,EAAE;YACzB,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,YAAY,qBAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,qBAAY,CAAC,IAAI,CAAC,IAAI,CAAC;YAC3E,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC;SAC7F,EAAE,IAAI,CAAC,EAAE,CAAC,qBAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAC1C,CAAC;IAEO,gBAAgB,CAAC,QAA4D,EAAE,QAAa,EAAE,KAAwB,EAAE,UAA2B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QAC1K,MAAM,MAAM,GAAG,oCAA2B,CAAC,MAAM,EAAE,CAAC;QAEpD,uBAAkB,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,kCACpD,OAAO,KACV,UAAU,EAAE,IAAI,CAAC,WAAW,EAC5B,gBAAgB,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,KACtG,KAAK,CAAC,CAAC;QAEV,OAAO,MAAM,CAAC;IAClB,CAAC;IAES,2BAA2B,CAAC,OAAe,EAAE,QAAa,EAAE,KAAY,EAAE,OAAgE;QAChJ,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IACvE,CAAC;IACS,oBAAoB,CAAC,OAAe,EAAE,QAAa,EAAE,KAAY,EAAE,OAAgE;QACzI,MAAM,kBAAkB,GAAG,IAAI,0BAAkB,CAAC,GAAG,OAAO,KAAK,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,MAAM,qCAA6B,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,GAAG,EACpJ,6BAAqB,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;QAC3C,kBAAkB,CAAC,KAAK,GAAG,GAAG,kBAAkB,CAAC,KAAK,gBAAgB,KAAK,CAAC,KAAK,EAAE,CAAC;QACpF,OAAO,kBAAkB,CAAC;IAC9B,CAAC;IAEO,KAAK,CAAC,kBAAkB,CAAC,QAAuD,EAAE,QAAa,EAAE,OAAyB;QAC9H,IAAI,MAAM,GAAG,MAAM,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAE/C,0BAA0B;QAC1B,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,QAAQ,EAAE;YACjD,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;SAC3C;QAED,wBAAwB;QACxB,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,MAAM,KAAK,QAAQ,EAAE;YAC/C,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;SAC5C;QAED,qCAAqC;QACrC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,MAAM,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAElE,OAAO,mCAA0B,CAAC,UAAU,CAAC,qBAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAC5E,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,QAAa,EAAE,OAAyB;QACnE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;QAErE,mCAAmC;QACnC,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,MAAM,IAAI,0BAAkB,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,gCAAgC,6BAAyC,OAAO,CAAC,CAAC;SACzK;QAED,qDAAqD;QACrD,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,KAAK,qBAAa,IAAI,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE;YAC7G,MAAM,IAAI,0BAAkB,CAAC,yBAAyB,mCAA+C,OAAO,CAAC,CAAC;SACjH;QAED,qCAAqC;QACrC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAE1D,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,sBAAsB,CAAC,QAAa,EAAE,IAAY,EAAE,OAAyB;QACjF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,EAAE;YACjB,IAAI,mBAAmB,GAAoC,SAAS,CAAC;YAErE,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,QAAQ,IAAI,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;gBAC3E,mBAAmB,oCAAgD,CAAC;aACvE;YAED,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE;gBACvE,mBAAmB,yBAAqC,CAAC;aAC5D;YAED,IAAI,OAAO,mBAAmB,KAAK,QAAQ,EAAE;gBACzC,MAAM,IAAI,0BAAkB,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,6BAA6B,EAAE,mBAAmB,CAAC,CAAC;aAC3I;SACJ;IACL,CAAC;IAED,aAAa;IAEb,yCAAyC;IAEzC,KAAK,CAAC,IAAI,CAAC,MAAW,EAAE,MAAW,EAAE,OAAyB;QAC1D,IAAI,QAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;SACzD;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,MAAM,EAAE,MAAM,eAAqB,CAAC;QAE5E,MAAM,KAAK,GAAG,EAAE,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,cAAoB,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;QACtG,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI,IAA0B,CAAC;QAC/B,IAAI;YACA,IAAI,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAC,CAAC;SAChE;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,KAAK,CAAC,MAAM,CAAC,MAAW,EAAE,MAAW,EAAE,SAAmB;QAChE,MAAM,cAAc,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC;QACtG,MAAM,cAAc,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC;QAEtG,OAAO;QACP,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC;QAExG,0BAA0B;QAC1B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;QACvE,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,0BAAkB,CAAC,MAAM,EAAE,IAAI,KAAK,MAAM,CAAC,CAAC,cAAoB,CAAC,aAAmB,EAAE,QAAQ,CAAC,CAAC,CAAC;QAExI,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,MAAW,EAAE,MAAW,EAAE,OAAyB;QAC1D,IAAI,QAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;SACzD;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,MAAM,EAAE,MAAM,eAAqB,CAAC;QAE5E,MAAM,KAAK,GAAG,EAAE,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,cAAoB,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;QACtG,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI,IAA0B,CAAC;QAC/B,IAAI;YACA,IAAI,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAC,CAAC;SAChE;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,KAAK,CAAC,MAAM,CAAC,MAAW,EAAE,MAAW,EAAE,SAAmB;QAChE,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QAC3D,MAAM,cAAc,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC;QAEtG,OAAO;QACP,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC;QAExG,0BAA0B;QAC1B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;QACvE,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,0BAAkB,CAAC,MAAM,EAAE,IAAI,KAAK,MAAM,CAAC,CAAC,cAAoB,CAAC,aAAmB,EAAE,QAAQ,CAAC,CAAC,CAAC;QAExI,OAAO,QAAQ,CAAC;IACpB,CAAC;IAEO,KAAK,CAAC,UAAU,CAAC,cAAkC,EAAE,MAAW,EAAE,cAAkC,EAAE,MAAW,EAAE,IAAqB,EAAE,SAAkB;QAChK,IAAI,MAAM,CAAC,QAAQ,EAAE,KAAK,MAAM,CAAC,QAAQ,EAAE,EAAE;YACzC,OAAO,IAAI,CAAC,CAAC,gEAAgE;SAChF;QAED,aAAa;QACb,MAAM,EAAE,MAAM,EAAE,mCAAmC,EAAE,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;QAEvJ,oCAAoC;QACpC,IAAI,MAAM,IAAI,CAAC,SAAS,EAAE;YACtB,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACjD,MAAM,IAAI,GAAG,mCAAmC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC;YACjG,MAAM,GAAG,kCAAe,CAAC,yBAAyB,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACpG;QAED,6EAA6E;QAC7E,IAAI,MAAM,IAAI,CAAC,mCAAmC,IAAI,SAAS,EAAE;YAC7D,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;SAClD;QAED,wBAAwB;QACxB,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;QAEjD,wBAAwB;QACxB,IAAI,IAAI,KAAK,MAAM,EAAE;YAEjB,8DAA8D;YAC9D,IAAI,cAAc,KAAK,cAAc,IAAI,mCAA2B,CAAC,cAAc,CAAC,EAAE;gBAClF,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;aAC5D;YAED,0DAA0D;YAC1D,uDAAuD;iBAClD;gBACD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBAC9C,IAAI,UAAU,CAAC,WAAW,EAAE;oBACxB,MAAM,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;iBAC/E;qBAAM;oBACH,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;iBACzE;aACJ;YAED,OAAO,IAAI,CAAC;SACf;QAED,wBAAwB;aACnB;YAED,iDAAiD;YACjD,IAAI,cAAc,KAAK,cAAc,EAAE;gBACnC,MAAM,cAAc,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;gBAE3D,OAAO,IAAI,CAAC;aACf;YAED,sDAAsD;iBACjD;gBACD,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;gBAEzF,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;gBAE/C,OAAO,MAAM,CAAC;aACjB;SACJ;IACL,CAAC;IAEO,KAAK,CAAC,UAAU,CAAC,cAAkC,EAAE,MAAW,EAAE,cAAkC,EAAE,MAAW;QAErH,+CAA+C;QAC/C,IAAI,uCAA+B,CAAC,cAAc,CAAC,IAAI,uCAA+B,CAAC,cAAc,CAAC,EAAE;YACpG,OAAO,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAC9E;QAED,iDAAiD;QACjD,IAAI,uCAA+B,CAAC,cAAc,CAAC,IAAI,8BAAsB,CAAC,cAAc,CAAC,EAAE;YAC3F,OAAO,IAAI,CAAC,0BAA0B,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAC1F;QAED,iDAAiD;QACjD,IAAI,8BAAsB,CAAC,cAAc,CAAC,IAAI,uCAA+B,CAAC,cAAc,CAAC,EAAE;YAC3F,OAAO,IAAI,CAAC,0BAA0B,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAC1F;QAED,mDAAmD;QACnD,IAAI,8BAAsB,CAAC,cAAc,CAAC,IAAI,8BAAsB,CAAC,cAAc,CAAC,EAAE;YAClF,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAChF;IACL,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,cAAkC,EAAE,YAAsB,EAAE,cAAkC,EAAE,YAAiB;QAExI,0BAA0B;QAC1B,MAAM,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;QAEzC,4BAA4B;QAC5B,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE;YACtC,MAAM,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAC,WAAW,EAAC,EAAE;gBAC5D,MAAM,WAAW,GAAG,YAAY,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC3D,IAAI,WAAW,CAAC,WAAW,EAAE;oBACzB,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,cAAc,EAAE,WAAW,CAAC,CAAC;iBACnH;qBAAM;oBACH,OAAO,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,WAAW,CAAC,QAAQ,EAAE,cAAc,EAAE,WAAW,CAAC,CAAC;iBAC7F;YACL,CAAC,CAAC,CAAC,CAAC;SACP;IACL,CAAC;IAEO,KAAK,CAAC,kBAAkB,CAAC,cAAkC,EAAE,MAAW,EAAE,cAAkC,EAAE,MAAW,EAAE,IAAqB,EAAE,SAAmB;QACzK,IAAI,mCAAmC,GAAG,KAAK,CAAC;QAEhD,mFAAmF;QACnF,IAAI,cAAc,KAAK,cAAc,EAAE;YACnC,MAAM,mBAAmB,GAAG,CAAC,CAAC,CAAC,cAAc,CAAC,YAAY,+BAAmD,CAAC,CAAC;YAC/G,IAAI,CAAC,mBAAmB,EAAE;gBACtB,mCAAmC,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,MAAM,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC;aAC7G;YAED,IAAI,mCAAmC,IAAI,IAAI,KAAK,MAAM,EAAE;gBACxD,MAAM,IAAI,KAAK,CAAC,+BAA+B,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,8DAA8D,CAAC,CAAC;aACpM;YAED,IAAI,CAAC,mCAAmC,IAAI,MAAM,CAAC,eAAe,CAAC,MAAM,EAAE,mBAAmB,CAAC,EAAE;gBAC7F,MAAM,IAAI,KAAK,CAAC,oCAAoC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,0BAA0B,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;aACjJ;SACJ;QAED,yDAAyD;QACzD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACzC,IAAI,MAAM,IAAI,CAAC,mCAAmC,EAAE;YAEhD,0EAA0E;YAC1E,0EAA0E;YAC1E,IAAI,cAAc,KAAK,cAAc,EAAE;gBACnC,MAAM,mBAAmB,GAAG,CAAC,CAAC,CAAC,cAAc,CAAC,YAAY,+BAAmD,CAAC,CAAC;gBAC/G,IAAI,MAAM,CAAC,eAAe,CAAC,MAAM,EAAE,mBAAmB,CAAC,EAAE;oBACrD,MAAM,IAAI,KAAK,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,WAAW,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,6DAA6D,CAAC,CAAC;iBAC/K;aACJ;SACJ;QAED,OAAO,EAAE,MAAM,EAAE,mCAAmC,EAAE,CAAC;IAC3D,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,QAAa;QAC5B,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QAE/F,oBAAoB;QACpB,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAEtC,SAAS;QACT,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;QACzE,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,0BAAkB,CAAC,QAAQ,kBAAwB,QAAQ,CAAC,CAAC,CAAC;QAErG,OAAO,QAAQ,CAAC;IACpB,CAAC;IAEO,KAAK,CAAC,MAAM,CAAC,QAA4B,EAAE,SAAc;QAC7D,MAAM,mBAAmB,GAAa,EAAE,CAAC;QAEzC,4BAA4B;QAC5B,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE;YAC3B,IAAI;gBACA,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC5C,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,gBAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;oBACxC,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,6CAA6C,CAAC,CAAC;iBAC7H;gBAED,MAAM,CAAC,8CAA8C;aACxD;YAAC,OAAO,KAAK,EAAE;gBAEZ,uDAAuD;gBACvD,IAAI,qCAA6B,CAAC,KAAK,CAAC,KAAK,mCAA2B,CAAC,YAAY,EAAE;oBACnF,MAAM,KAAK,CAAC;iBACf;gBAED,2DAA2D;gBAC3D,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAE9C,cAAc;gBACd,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC;aAChC;SACJ;QAED,+BAA+B;QAC/B,KAAK,IAAI,CAAC,GAAG,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YACtD,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC;YAEtD,IAAI;gBACA,MAAM,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;aACnC;YAAC,OAAO,KAAK,EAAE;gBACZ,IAAI,qCAA6B,CAAC,KAAK,CAAC,KAAK,mCAA2B,CAAC,UAAU,EAAE;oBACjF,uDAAuD;oBACvD,0DAA0D;oBAC1D,0DAA0D;oBAC1D,2DAA2D;oBAC3D,mDAAmD;oBACnD,2DAA2D;oBAC3D,yCAAyC;oBACzC,8DAA8D;oBAC9D,MAAM,KAAK,CAAC;iBACf;aACJ;SACJ;IACL,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,OAA2D;QACnF,IAAI,QAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SAC3C;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,QAAQ,EAAE,SAAS,iBAAuB,CAAC;QAEnF,MAAM,KAAK,GAAG,EAAE,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,gBAAsB,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC;QAC1G,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI;YACA,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SAC1C;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACxD,CAAC;IAES,KAAK,CAAC,QAAQ,CAAC,QAAa,EAAE,OAAoC;QACxE,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QAE/F,yBAAyB;QACzB,MAAM,QAAQ,GAAG,CAAC,EAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,EAAC;QACrC,IAAI,QAAQ,IAAI,CAAC,CAAC,QAAQ,CAAC,YAAY,mBAAuC,CAAC,EAAE;YAC7E,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,mDAAmD,CAAC,CAAC;SACjI;QAED,kBAAkB;QAClB,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,MAAM,EAAE;YACT,MAAM,IAAI,0BAAkB,CAAC,uCAAuC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,GAAG,yBAAqC,CAAC;SAC/I;QAED,qBAAqB;QACrB,MAAM,SAAS,GAAG,CAAC,EAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,EAAC;QACvC,IAAI,CAAC,SAAS,IAAI,MAAM,EAAE;YACtB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YAC1C,IAAI,IAAI,CAAC,WAAW,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC9E,MAAM,IAAI,KAAK,CAAC,sCAAsC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;aAC9F;SACJ;QAED,0BAA0B;QAC1B,MAAM,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,QAAQ,EAAE,CAAC,CAAC;QAEzD,SAAS;QACT,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,0BAAkB,CAAC,QAAQ,iBAAuB,CAAC,CAAC;IAC/F,CAAC;IAcD,KAAK,CAAC,QAAa,EAAE,UAAwB,EAAE,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,EAAE;QAC3E,MAAM,eAAe,mCACd,OAAO;YACV,uCAAuC;YACvC,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,mBAAmB,CAAC,GACzD,CAAC;QAEF,IAAI,aAAa,GAAG,KAAK,CAAC;QAC1B,IAAI,eAAe,GAAG,uBAAU,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC,CAAC;QAEpE,kDAAkD;QAClD,iDAAiD;QACjD,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACtD,IAAI,aAAa,EAAE;gBACf,UAAU,CAAC,OAAO,EAAE,CAAC;aACxB;iBAAM;gBACH,eAAe,GAAG,UAAU,CAAC;aAChC;QACL,CAAC,EAAE,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;QAElC,OAAO,uBAAU,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC,CAAC;IAC9D,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,QAAa,EAAE,OAAqB;QAC9C,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACnD,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QAEzD,4DAA4D;QAC5D,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,UAAU,EAAE,QAAQ,CAAC,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE,CAAC;QAC5G,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YAC/B,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;SACzC;QAED,0BAA0B;QAC1B,OAAO,CAAC,KAAK,IAAI,CAAC,CAAC;QAEnB,OAAO,uBAAU,CAAC,MAAM,CAAC,GAAG,EAAE;YAE1B,QAAQ;YACR,OAAO,CAAC,KAAK,EAAE,CAAC;YAEhB,yCAAyC;YACzC,IAAI,OAAO,CAAC,KAAK,KAAK,CAAC,EAAE;gBACrB,OAAO,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;gBAC7B,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aACnC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,UAAU,CAAC,QAA4B,EAAE,QAAa,EAAE,OAAqB;QACjF,OAAO;YACH,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC;YACjC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC;YACzB,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAa,kCAAkC;SACzE,CAAC,IAAI,EAAE,CAAC;IACb,CAAC;IAQO,gBAAgB,CAAC,QAA4B,EAAE,QAAa,EAAE,IAAyB;QAC3F,+DAA+D;QAC/D,4DAA4D;QAC5D,kDAAkD;QAClD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACnD,MAAM,UAAU,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC1F,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;QAC3C,OAAO,UAAU,CAAC;IACtB,CAAC;IAEO,QAAQ,CAAC,QAA4B,EAAE,QAAa;QACxD,MAAM,mBAAmB,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,+BAAmD,CAAC,CAAC;QAEzG,OAAO,mBAAmB,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC;IACzF,CAAC;IAEO,KAAK,CAAC,eAAe,CAAC,QAA4D,EAAE,QAAa,EAAE,gCAAwH;QAC/N,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,IAAI,EAAE;YAExD,cAAc;YACd,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;YAE/D,kEAAkE;YAClE,IAAI;gBACA,IAAI,yBAAgB,CAAC,gCAAgC,CAAC,IAAI,iCAAwB,CAAC,gCAAgC,CAAC,EAAE;oBAClH,MAAM,IAAI,CAAC,2BAA2B,CAAC,QAAQ,EAAE,MAAM,EAAE,gCAAgC,CAAC,CAAC;iBAC9F;qBAAM;oBACH,MAAM,IAAI,CAAC,6BAA6B,CAAC,QAAQ,EAAE,MAAM,EAAE,gCAAgC,CAAC,CAAC;iBAChG;aACJ;YAAC,OAAO,KAAK,EAAE;gBACZ,MAAM,qCAA6B,CAAC,KAAK,CAAC,CAAC;aAC9C;oBAAS;gBAEN,sBAAsB;gBACtB,MAAM,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;aAChC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,KAAK,CAAC,2BAA2B,CAAC,QAA4D,EAAE,MAAc,EAAE,sBAAuF;QAC3M,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,MAAkC,CAAC;QAEvC,uDAAuD;QACvD,mDAAmD;QACnD,IAAI,iCAAwB,CAAC,sBAAsB,CAAC,EAAE;YAClD,IAAI,sBAAsB,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC1C,MAAM,KAAK,GAAG,qBAAY,CAAC,MAAM,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;gBACjE,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;gBAElF,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC;aACjC;YAED,gDAAgD;YAChD,IAAI,sBAAsB,CAAC,KAAK,EAAE;gBAC9B,OAAO;aACV;YAED,MAAM,GAAG,sBAAsB,CAAC,MAAM,CAAC;SAC1C;QAED,sCAAsC;aACjC;YACD,MAAM,GAAG,sBAAsB,CAAC;SACnC;QAED,OAAO,IAAI,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE;YAEzC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,KAAK,EAAC,KAAK,EAAC,EAAE;gBAE5B,gDAAgD;gBAChD,MAAM,CAAC,KAAK,EAAE,CAAC;gBAEf,IAAI;oBACA,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;iBACrF;gBAAC,OAAO,KAAK,EAAE;oBACZ,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;iBACxB;gBAED,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC;gBAE9B,sDAAsD;gBACtD,sDAAsD;gBACtD,sDAAsD;gBACtD,kCAAkC;gBAClC,UAAU,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;YACtC,CAAC,CAAC,CAAC;YAEH,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;YAC3C,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,KAAK,CAAC,6BAA6B,CAAC,QAA4D,EAAE,MAAc,EAAE,QAA8B;QACpJ,IAAI,SAAS,GAAG,CAAC,CAAC;QAElB,IAAI,KAA0B,CAAC;QAC/B,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC,KAAK,IAAI,EAAE;YACvC,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;YAElF,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC;SACjC;IACL,CAAC;IAEO,KAAK,CAAC,aAAa,CAAC,QAA4D,EAAE,MAAc,EAAE,MAAoB,EAAE,MAAc,EAAE,SAAiB,EAAE,WAAmB;QAClL,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAC1B,OAAO,iBAAiB,GAAG,MAAM,EAAE;YAC/B,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,SAAS,GAAG,iBAAiB,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,GAAG,iBAAiB,EAAE,MAAM,GAAG,iBAAiB,CAAC,CAAC;YAC7J,iBAAiB,IAAI,YAAY,CAAC;SACrC;IACL,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAAuD,EAAE,QAAa,EAAE,wCAA+I;QACnP,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,QAAQ,EAAE,wCAAwC,CAAC,CAAC,CAAC;IACvJ,CAAC;IAEO,KAAK,CAAC,uBAAuB,CAAC,QAAuD,EAAE,QAAa,EAAE,wCAA+I;QACzP,IAAI,MAAoB,CAAC;QACzB,IAAI,wCAAwC,YAAY,qBAAY,EAAE;YAClE,MAAM,GAAG,wCAAwC,CAAC;SACrD;aAAM,IAAI,yBAAgB,CAAC,wCAAwC,CAAC,EAAE;YACnE,MAAM,GAAG,MAAM,mCAA0B,CAAC,QAAQ,CAAC,wCAAwC,CAAC,CAAC;SAChG;aAAM,IAAI,iCAAwB,CAAC,wCAAwC,CAAC,EAAE;YAC3E,MAAM,GAAG,MAAM,2CAAkC,CAAC,QAAQ,CAAC,wCAAwC,CAAC,CAAC;SACxG;aAAM;YACH,MAAM,GAAG,6BAAoB,CAAC,QAAQ,CAAC,wCAAwC,CAAC,CAAC;SACpF;QAED,OAAO,QAAQ,CAAC,SAAS,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IAC1F,CAAC;IAEO,KAAK,CAAC,cAAc,CAAC,cAAkE,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QACzL,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IAC1I,CAAC;IAEO,KAAK,CAAC,oBAAoB,CAAC,cAAkE,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QAC/L,IAAI,YAAY,GAAuB,SAAS,CAAC;QACjD,IAAI,YAAY,GAAuB,SAAS,CAAC;QAEjD,IAAI;YAEA,eAAe;YACf,YAAY,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;YACpE,YAAY,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;YAEnE,MAAM,MAAM,GAAG,qBAAY,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAEpD,IAAI,SAAS,GAAG,CAAC,CAAC;YAClB,IAAI,WAAW,GAAG,CAAC,CAAC;YACpB,IAAI,SAAS,GAAG,CAAC,CAAC;YAClB,GAAG;gBACC,0FAA0F;gBAC1F,kFAAkF;gBAClF,SAAS,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,YAAY,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,EAAE,MAAM,CAAC,UAAU,GAAG,WAAW,CAAC,CAAC;gBAE5H,2FAA2F;gBAC3F,+DAA+D;gBAC/D,MAAM,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,YAAY,EAAE,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;gBAElG,SAAS,IAAI,SAAS,CAAC;gBACvB,WAAW,IAAI,SAAS,CAAC;gBAEzB,qDAAqD;gBACrD,IAAI,WAAW,KAAK,MAAM,CAAC,UAAU,EAAE;oBACnC,WAAW,GAAG,CAAC,CAAC;iBACnB;aACJ,QAAQ,SAAS,GAAG,CAAC,EAAE;SAC3B;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,qCAA6B,CAAC,KAAK,CAAC,CAAC;SAC9C;gBAAS;YACN,MAAM,OAAO,CAAC,GAAG,CAAC;gBACd,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE;gBACzF,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE;aAC5F,CAAC,CAAC;SACN;IACL,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,cAA6D,EAAE,MAAW,EAAE,cAA6D,EAAE,MAAW;QACjL,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IAC5I,CAAC;IAEO,KAAK,CAAC,sBAAsB,CAAC,cAA6D,EAAE,MAAW,EAAE,cAA6D,EAAE,MAAW;QACvL,OAAO,cAAc,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACtH,CAAC;IAEO,KAAK,CAAC,0BAA0B,CAAC,cAA6D,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QAChM,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,gCAAgC,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IACtJ,CAAC;IAEO,KAAK,CAAC,gCAAgC,CAAC,cAA6D,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QAEtM,cAAc;QACd,MAAM,YAAY,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;QAEzE,oDAAoD;QACpD,IAAI;YACA,MAAM,MAAM,GAAG,MAAM,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACrD,MAAM,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,YAAY,EAAE,qBAAY,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC9G;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,qCAA6B,CAAC,KAAK,CAAC,CAAC;SAC9C;gBAAS;YACN,MAAM,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;SAC5C;IACL,CAAC;IAEO,KAAK,CAAC,0BAA0B,CAAC,cAAkE,EAAE,MAAW,EAAE,cAA6D,EAAE,MAAW;QAEhM,kCAAkC;QAClC,MAAM,MAAM,GAAG,MAAM,mCAA0B,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,gCAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;QAEhI,mCAAmC;QACnC,MAAM,IAAI,CAAC,iBAAiB,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACjE,CAAC;IAES,2BAA2B,CAA+B,QAAW,EAAE,QAAa;QAC1F,IAAI,QAAQ,CAAC,YAAY,sBAA0C,EAAE;YACjE,MAAM,IAAI,0BAAkB,CAAC,kCAAkC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE,iCAA6C,CAAC;SACjJ;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAEO,gBAAgB,CAAC,QAAa;QAClC,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IACpD,CAAC;IAQD,2BAA2B,CAAC,WAAqC;QAC7D,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAEpC,OAAO,uBAAU,CAAC,MAAM,CAAC,GAAG,EAAE;YAC1B,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YACrD,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;gBACZ,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;aACtC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED,KAAK,CAAC,4BAA4B,CAAC,MAAW,EAAE,MAAuB,EAAE,SAAwB;QAC7F,MAAM,mBAAmB,GAAG,IAAI,CAAC,WAAW,CAAC,4BAA4B,CAAC,CAAC;QAC3E,IAAI,mBAAmB,IAAI,CAAC,EAAE;YAC1B,OAAO;SACV;QAED,MAAM,uBAAuB,GAAG,IAAI,sCAAuB,EAAE,CAAC;QAE9D,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,KAAK,IAAI,EAAE;YACzF,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,YAAY,EAAE;gBACzC,IAAI,uBAAuB,CAAC,KAAK,CAAC,uBAAuB,EAAE;oBACvD,MAAM;iBACT;gBAED,IAAI;oBACA,MAAM,OAAO,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,mBAAmB,EAAE,uBAAuB,CAAC,KAAK,CAAC,CAAC;oBACvH,MAAM,OAAO,CAAC,IAAI,CAAC;wBACf,OAAO;wBACP,sBAAO,CAAC,mBAAmB,EAAE,uBAAuB,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,uBAAuB,CAAC,OAAO,EAAE,EAAE,GAAG,EAAE,GAA4B,CAAC,CAAC;qBAChJ,CAAC,CAAC;iBACN;gBAAC,OAAO,GAAG,EAAE;oBACV,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACrB;aACJ;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,aAAa,CAAC,SAAwB;QAC1C,QAAQ,SAAS,EAAE;YACf;gBACI,OAAO,uCAAuC,CAAC;YACnD;gBACI,OAAO,uCAAuC,CAAC;YACnD;gBACI,OAAO,qCAAqC,CAAC;YACjD;gBACI,OAAO,uCAAuC,CAAC;SACtD;IACL,CAAC;IAED,aAAa;IAEb,mBAAmB;IAET,KAAK,CAAC,gBAAgB,CAAC,QAAa,EAAE,OAA8B;QAC1E,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QACrG,OAAO,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,QAAQ,EAAE;YACrD,iBAAiB,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB;YAC7C,IAAI,EAAE,KAAK,EAAC,MAAM,EAAC,EAAE;gBACjB,MAAM,MAAM,GAAG,MAAM,mCAA0B,CAAC,QAAQ,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBAClH,OAAO,MAAM,CAAC,MAAM,CAAC;YACzB,CAAC;SACJ,CAAC,CAAC;IACP,CAAC;IAES,eAAe,CAAC,QAAa,EAAE,OAA6B,EAAE,gBAAyB;QAC7F,IAAI,iBAAqC,CAAC;QAE1C,+BAA+B;QAC/B,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,EAAE;YACnB,IAAI,gBAAgB,KAAK,yBAAa,IAAI,OAAO,CAAC,QAAQ,KAAK,gBAAI,EAAE;gBACjE,iBAAiB,GAAG,yBAAa,CAAC,CAAC,4DAA4D;aAClG;iBAAM;gBACH,iBAAiB,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,2CAA2C;aACpF;SACJ;aAAM,IAAI,gBAAgB,EAAE;YACzB,iBAAiB,GAAG,gBAAgB,CAAC;SACxC;QAED,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,CAAC;IACpE,CAAC;IAES,KAAK,CAAC,sBAAsB,CAAC,QAAa,EAAE,iBAA0B;QAC5E,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;QACrD,OAAO,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,CAAC;IACrF,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,oBAAoB,CAAC,QAAa;QACpC,IAAI,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACjD,OAAO,QAAQ,YAAY,8DAA4B,EAAE;YACrD,QAAQ,GAAG,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;YACnD,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;SAChD;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,aAAa;IAEH,oBAAoB;QAC1B,IAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,CAAC;IAC3C,CAAC;CACJ;AAj+CG;IADC,kBAAM,CAAC,8BAAa,CAAC;8BACY,8BAAa;kDAAC;AAGhD;IADC,kBAAM,CAAC,8CAAqB,CAAC;;gDACwB;AAGtD;IADC,kBAAM,CAAC,kCAAe,CAAC;8BACY,kCAAe;oDAAC;AAGpD;IADC,kBAAM,CAAC,oCAAgB,CAAC;8BACY,oCAAgB;qDAAC;AAGtD;IADC,kBAAM,CAAC,kCAAe,CAAC;8BACY,kCAAe;oDAAC;AAGpD;IADC,kBAAM,CAAC,4CAAoB,CAAC;IAAE,iBAAK,CAAC,+BAAuB,CAAC;;kDACmB;AAGhF;IADC,kBAAM,CAAC,gEAA6B,CAAC;8BACE,gEAA6B;wDAAC;AAGtE;IADC,yBAAa,EAAE;;;;uCAKf;AA9BQ,WAAW;IADvB,sBAAU,EAAE;GACA,WAAW,CAs+CvB;AAt+CY,kCAAW;;;;;;;;;;;;;AC9QxB;;;;;;;;;;;;;;kFAckF;;;AAGlF,qJAM6C;AAC7C,uKAAkF;AAElF,uDAAuD;AAC1C,8BAAsB,GAAG,GAAG,CAAC,CAAC,SAAS;AACvC,gCAAwB,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,QAAQ;AAE9C,wBAAgB,GAAG,OAAO,OAAO,KAAK,QAAQ;IACvD,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,MAAM;QACrB,CAAC,CAAC,8BAAsB;QACxB,CAAC,CAAC,gCAAwB;IAC9B,CAAC,CAAC,EAAE,CAAC;AAEI,kCAA0B,GAAqB;IACxD,IAAI,EAAE,QAAQ;IACd,UAAU,EAAE;QACR,sBAAsB,EAAE;YACpB,WAAW,EAAE,sDAAsD;YACnE,oBAAoB,EAAE;gBAClB,IAAI,EAAE,SAAS;aAClB;YACD,OAAO,EAAE;gBACL,oBAAoB,EAAE,IAAI;gBAC1B,0BAA0B,EAAE,IAAI;gBAChC,oBAAoB,EAAE,IAAI;aAC7B;YACD,KAAK,EAAE,UAAU;SACpB;QACD,eAAe,EAAE;YACb,IAAI,EAAE,QAAQ;YACd,OAAO,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,cAAc,EAAE,IAAI,EAAE;YACnG,WAAW,EAAE,0DAA0D;YACvE,KAAK,EAAE,UAAU;SACpB;QACD,mBAAmB,EAAE;YACjB,IAAI,EAAE,SAAS;YACf,OAAO,EAAE,IAAI;YACb,WAAW,EAAE,mIAAmI;SACnJ;QACD,oBAAoB,EAAE;YAClB,IAAI,EAAE,QAAQ;YACd,WAAW,EAAE;gFACuD;SACvE;QACD,yBAAyB,EAAE;YACvB,IAAI,EAAE,SAAS;YACf,OAAO,EAAE,KAAK;YACd,WAAW,EAAE,iJAAiJ;YAC9J,KAAK,EAAE,sBAAsB;YAC7B,QAAQ,EAAE,MAAM,CAAC,IAAI,CAAC,yCAAmB,CAAC,CAAC,MAAM,GAAG,CAAC;SACxD;QACD,4BAA4B,EAAE;YAC1B,IAAI,EAAE,QAAQ;YACd,OAAO,EAAE,IAAI;YACb,mBAAmB,EAAE,sIAAsI;SAC9J;QACD,qBAAqB,EAAE;YACnB,IAAI,EAAE,QAAQ;YACd,OAAO,EAAE,wBAAgB;YACzB,mBAAmB,EAAE,6DAA6D;SACrF;QACD,8BAA8B,EAAE;YAC5B,IAAI,EAAE,SAAS;YACf,OAAO,EAAE,KAAK;YACd,WAAW,EAAE,iEAAiE;YAC9E,KAAK,EAAE,sBAAsB;SAChC;QACD,4BAA4B,EAAE;YAC1B,IAAI,EAAE,SAAS;YACf,OAAO,EAAE,CAAC;YACV,WAAW,EAAE,8HAA8H;SAC9I;KACJ;CACJ,CAAC;AAeW,wCAAgC,GAAG,MAAM,CAAC,kCAAkC,CAAC,CAAC;AAC9E,6BAAqB,GAAG,MAAM,CAAC,uBAAuB,CAAC,CAAC;AAGrE,SAAgB,2BAA2B,CAAC,WAA8B,EAAE,SAA2B,kCAA0B;IAC7H,OAAO,mCAAqB,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;AACtD,CAAC;AAFD,kEAEC;AAED,SAAgB,yBAAyB,CAAC,IAAqB;IAC3D,IAAI,CAAC,6BAAqB,CAAC,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;QAC7C,MAAM,WAAW,GAAG,GAAG,CAAC,SAAS,CAAC,GAAG,CAAoB,+BAAiB,CAAC,CAAC;QAC5E,MAAM,YAAY,GAAG,GAAG,CAAC,SAAS,CAAC,GAAG,CAAyB,wCAAgC,CAAC,CAAC;QACjG,OAAO,2BAA2B,CAAC,WAAW,EAAE,YAAY,CAAC,MAAM,CAAC,CAAC;IACzE,CAAC,CAAC,CAAC,gBAAgB,EAAE,CAAC;IACtB,IAAI,CAAC,wCAAgC,CAAC,CAAC,eAAe,CAAC,EAAE,MAAM,EAAE,kCAA0B,EAAE,CAAC,CAAC;IAC/F,IAAI,CAAC,oCAAsB,CAAC,CAAC,SAAS,CAAC,wCAAgC,CAAC,CAAC;AAC7E,CAAC;AARD,8DAQC;;;;;;;;;;;;;AC/HD;;;;;;;;;;;;;;kFAckF;;;;;;;;;;;;AAElF,+HAAkE;AAClE,mMAA4F;AAC5F,yGAA6C;AAC7C,sKAA8E;AAG9E,IAAa,6BAA6B,GAA1C,MAAa,6BAA6B;IAA1C;QAKc,0BAAqB,GAAY,KAAK,CAAC;IAgCrD,CAAC;IA9BG,IAAc,gBAAgB;QAC1B,OAAO,6IAA6I,CAAC;IACzJ,CAAC;IAEM,KAAK,CAAC,WAAW;QACpB,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE;YAC7B,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;YAClC,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;gBACnB,MAAM,kBAAkB,GAAG,cAAc,CAAC;gBAC1C,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CACzC,uHAAuH,EACvH,EAAE,OAAO,EAAE,KAAK,EAAE,EAClB,kBAAkB,CACrB,CAAC;gBACF,IAAI,MAAM,KAAK,kBAAkB,EAAE;oBAC/B,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;iBAC/E;aACJ;iBAAM;gBACH,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAC1B,yHAAyH,EACzH,EAAE,OAAO,EAAE,KAAK,EAAE,CACrB,CAAC;aACL;SACJ;IACL,CAAC;IAES,UAAU;QAChB,OAAO,yBAAW,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;IACrC,CAAC;CAEJ;AAnC2B;IAAvB,kBAAM,CAAC,qBAAc,CAAC;8BAAoC,qBAAc;qEAAC;AACnD;IAAtB,kBAAM,CAAC,8BAAa,CAAC;;oEAAiD;AAH9D,6BAA6B;IADzC,sBAAU,EAAE;GACA,6BAA6B,CAqCzC;AArCY,sEAA6B;;;;;;;;;;;;;ACtB1C;;;;;;;;;;;;;;kFAckF;;;AAGlF,sHAA2E;AAC3E,0IAAqF;AACrF,4GAKiB;AAIjB,MAAa,4BAA4B;IAQrC,YACuB,QAA4B,EAC5B,OAA6C,EAC7C,YAAY,IAAI,iCAAoB,EAAE;QAFtC,aAAQ,GAAR,QAAQ,CAAoB;QAC5B,YAAO,GAAP,OAAO,CAAsC;QAC7C,cAAS,GAAT,SAAS,CAA6B;QAT5C,2BAAsB,GAAG,IAAI,gBAAO,EAAyB,CAAC;QACtE,oBAAe,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC;QAE5C,4BAAuB,GAAG,IAAI,gBAAO,EAAQ,CAAC;QACtD,qBAAgB,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC;QAO3D,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;QACjD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC1F,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;QAClD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACnG,CAAC;IAED,OAAO;QACH,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;IAC7B,CAAC;IAED,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;IACtC,CAAC;IAED,IAAI,uBAAuB;QACvB,OAAO,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC;IACjD,CAAC;IAED,KAAK,CAAC,QAAa,EAAE,IAAkB;QACnC,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC;IAC1E,CAAC;IAED,IAAI,CAAC,QAAa;QACd,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;IACnE,CAAC;IAED,MAAM,CAAC,QAAa,EAAE,IAAa;QAC/B,IAAI,2BAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC;SAC1E;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,MAAM,CAAC,QAAa;QAChB,IAAI,2BAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;SACpE;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,KAAK,CAAC,QAAa;QACf,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;IACpE,CAAC;IAED,MAAM,CAAC,IAAS,EAAE,EAAO,EAAE,IAA0B;QACjD,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,oBAAoB,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;IACtG,CAAC;IAED,IAAI,CAAC,IAAS,EAAE,EAAO,EAAE,IAA0B;QAC/C,IAAI,mCAA2B,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAC5C,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,oBAAoB,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;SACnG;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,QAAQ,CAAC,QAAa;QAClB,IAAI,8BAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACvC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;SACtE;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,cAAc,CAAC,QAAa,EAAE,IAA2B,EAAE,KAAwB;QAC/E,IAAI,mCAA2B,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAC5C,OAAO,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;SACzF;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,OAAO,CAAC,QAAa;QACjB,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;IACtE,CAAC;IAED,SAAS,CAAC,QAAa,EAAE,OAAmB,EAAE,IAAsB;QAChE,IAAI,8BAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACvC,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;SACtF;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,IAAI,CAAC,QAAa,EAAE,IAAqB;QACrC,IAAI,uCAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC;SACxE;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,KAAK,CAAC,EAAU;QACZ,IAAI,uCAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;SAClC;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,IAAI,CAAC,EAAU,EAAE,GAAW,EAAE,IAAgB,EAAE,MAAc,EAAE,MAAc;QAC1E,IAAI,uCAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;SAC5D;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,KAAK,CAAC,EAAU,EAAE,GAAW,EAAE,IAAgB,EAAE,MAAc,EAAE,MAAc;QAC3E,IAAI,uCAA+B,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;SAC7D;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAED,MAAM,CAAC,QAAa,EAAE,IAAuB;QACzC,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC;IAC3E,CAAC;IAED,UAAU,CAAC,QAAa,EAAE,OAAyC,EAAE,IAAuB;QACxF,IAAI,2BAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;SAC5D;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACrC,CAAC;IAES,iBAAiB,CAAC,OAA8B;QACtD,MAAM,iBAAiB,GAAiB,EAAE,CAAC;QAC3C,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;YAC1B,MAAM,kBAAkB,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YACxE,IAAI,kBAAkB,EAAE;gBACpB,iBAAiB,CAAC,IAAI,CAAC;oBACnB,QAAQ,EAAE,kBAAkB;oBAC5B,IAAI,EAAE,MAAM,CAAC,IAAI;iBACpB,CAAC,CAAC;aACN;SACJ;QACD,IAAI,iBAAiB,CAAC,MAAM,EAAE;YAC1B,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;SACvD;IACL,CAAC;IAED;;;;;OAKG;IACH,oBAAoB,CAAC,QAAa;QAC9B,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;QAC1D,IAAI,CAAC,UAAU,EAAE;YACb,MAAM,IAAI,KAAK,CAAC,oBAAoB,GAAG,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;SAC/D;QACD,OAAO,UAAU,CAAC;IACtB,CAAC;IAED;;;;;;OAMG;IACH,sBAAsB,CAAC,QAAa;QAChC,OAAO,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACpD,CAAC;CAEJ;AA7KD,oEA6KC;;;;;;;;;;;;;ACzMD;;;;;;;;;;;;;;kFAckF;AAClF;;;gGAGgG;AAChG,mIAAmI;;;AAEnI,qHAA6C;AAe7C,MAAa,kBAAkB;IAI3B,YAA4B,QAAa,EAAkB,SAAwB,EAAkB,MAA6B;QAAtG,aAAQ,GAAR,QAAQ,CAAK;QAAkB,cAAS,GAAT,SAAS,CAAe;QAAkB,WAAM,GAAN,MAAM,CAAuB;IAAI,CAAC;IAIvI,WAAW,CAAC,SAAwB;QAChC,OAAO,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC;IACxC,CAAC;CACJ;AAXD,gDAWC;AA2BD,MAAa,gBAAgB;IAEzB,YAA4B,OAA8B;QAA9B,YAAO,GAAP,OAAO,CAAuB;IAAI,CAAC;IAE/D;;;;OAIG;IACH,QAAQ,CAAC,QAAa,EAAE,IAAqB;QACzC,IAAI,CAAC,QAAQ,EAAE;YACX,OAAO,KAAK,CAAC;SAChB;QAED,MAAM,kBAAkB,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC;QAEpD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YAC9B,IAAI,kBAAkB,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,EAAE;gBAC5C,OAAO,KAAK,CAAC;aAChB;YAED,4EAA4E;YAC5E,IAAI,MAAM,CAAC,IAAI,oBAA2B,EAAE;gBACxC,OAAO,QAAQ,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;aACpD;YAED,OAAO,QAAQ,CAAC,QAAQ,EAAE,KAAK,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;QAC9D,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACH,QAAQ;QACJ,OAAO,IAAI,CAAC,SAAS,eAAsB,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,QAAQ;QACJ,OAAO,IAAI,CAAC,OAAO,eAAsB,CAAC;IAC9C,CAAC;IAED;;OAEG;IACH,UAAU;QACN,OAAO,IAAI,CAAC,SAAS,iBAAwB,CAAC;IAClD,CAAC;IAED;;OAEG;IACH,UAAU;QACN,OAAO,IAAI,CAAC,OAAO,iBAAwB,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,UAAU;QACN,OAAO,IAAI,CAAC,SAAS,iBAAwB,CAAC;IAClD,CAAC;IAED;;OAEG;IACH,UAAU;QACN,OAAO,IAAI,CAAC,OAAO,iBAAwB,CAAC;IAChD,CAAC;IAEO,SAAS,CAAC,IAAoB;QAClC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;IAC/D,CAAC;IAEO,OAAO,CAAC,IAAoB;QAChC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;IAC7D,CAAC;CACJ;AA/ED,4CA+EC;AAgDD,IAAiB,QAAQ,CAOxB;AAPD,WAAiB,QAAQ;IACrB,SAAgB,EAAE,CAAC,GAAuB;QACtC,OAAO,CAAC,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ;YACnC,8DAA8D;eAC3D,CAAC,UAAU,IAAI,GAAG,IAAS,GAAG,CAAC,UAAU,CAAC,YAAY,aAAG,CAAC;eAC1D,CAAC,MAAM,IAAI,GAAG,IAAI,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,QAAQ,CAAC,CAAC;IAC9D,CAAC;IALe,WAAE,KAKjB;AACL,CAAC,EAPgB,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAOxB;AAkCD,IAAiB,QAAQ,CAiDxB;AAjDD,WAAiB,QAAQ;IACrB,SAAgB,EAAE,CAAC,GAAuB;QACtC,OAAO,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC;YACnB,CAAC,QAAQ,IAAI,GAAG,IAAI,OAAO,GAAG,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC;YACvD,CAAC,aAAa,IAAI,GAAG,IAAI,OAAO,GAAG,CAAC,aAAa,CAAC,KAAK,SAAS,CAAC;YACjE,CAAC,gBAAgB,IAAI,GAAG,IAAI,OAAO,GAAG,CAAC,gBAAgB,CAAC,KAAK,SAAS,CAAC,CAAC;IAChF,CAAC;IALe,WAAE,KAKjB;IACD,SAAgB,UAAU,CAAC,IAAc;QACrC,IAAI,GAAG,GAAG,CAAC,CAAC;QACZ,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC;SAExB;aAAM,IAAI,IAAI,CAAC,WAAW,EAAE;YACzB,GAAG,IAAI,QAAQ,CAAC,SAAS,CAAC;SAC7B;QACD,IAAI,IAAI,CAAC,cAAc,EAAE;YACrB,GAAG,IAAI,QAAQ,CAAC,YAAY,CAAC;SAChC;QACD,OAAO,GAAG,CAAC;IACf,CAAC;IAZe,mBAAU,aAYzB;IACD,SAAgB,MAAM,CAAC,IAAc;QACjC,OAAO;YACH,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC;YACtB,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;SAClB,CAAC;IACN,CAAC;IAPe,eAAM,SAOrB;IAGD,SAAgB,QAAQ,CAAC,QAAa,EAAE,IAA+C;QACnF,OAAO;YACH,QAAQ;YACR,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE;YACpD,MAAM,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;YACzC,WAAW,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC;YACnD,cAAc,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC;YACzD,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,IAAI,EAAE,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;SACrD,CAAC;IACN,CAAC;IAZe,iBAAQ,WAYvB;IACD,SAAgB,GAAG,CAAC,QAAsB,EAAE,IAAkC;QAC1E,OAAO,QAAQ,CAAC,QAAQ,YAAY,aAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,aAAG,CAAC,QAAQ,CAAC,kBAAI,IAAI,EAAE,QAAQ,CAAC,SAAS,IAAK,IAAI,EAAG,CAAC;IACnH,CAAC;IAFe,YAAG,MAElB;IACD,SAAgB,IAAI,CAAC,QAAsB,EAAE,IAAkC;QAC3E,OAAO,QAAQ,CAAC,QAAQ,YAAY,aAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,aAAG,CAAC,QAAQ,CAAC,kBAAI,IAAI,EAAE,QAAQ,CAAC,IAAI,IAAK,IAAI,EAAG,CAAC;IAC9G,CAAC;IAFe,aAAI,OAEnB;AACL,CAAC,EAjDgB,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAiDxB;AAiHD,MAAa,kBAAmB,SAAQ,KAAK;IACzC,YAAY,OAAe,EAAS,mBAAwC,EAAS,OAAgE;QACjJ,KAAK,CAAC,OAAO,CAAC,CAAC;QADiB,wBAAmB,GAAnB,mBAAmB,CAAqB;QAAS,YAAO,GAAP,OAAO,CAAyD;QAEjJ,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,kBAAkB,CAAC,SAAS,CAAC,CAAC;IAC9D,CAAC;CACJ;AALD,gDAKC;AAuED,IAAY,QAKX;AALD,WAAY,QAAQ;IAChB,6CAAW;IACX,uCAAQ;IACR,iDAAa;IACb,wDAAiB;AACrB,CAAC,EALW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAKnB;AAuCD,IAAY,2BAUX;AAVD,WAAY,2BAA2B;IACnC,yDAA0B;IAC1B,6DAA8B;IAC9B,uEAAwC;IACxC,qEAAsC;IACtC,iFAAkD;IAClD,6DAA8B;IAC9B,8DAA+B;IAC/B,0DAA2B;IAC3B,kDAAmB;AACvB,CAAC,EAVW,2BAA2B,GAA3B,mCAA2B,KAA3B,mCAA2B,QAUtC;AAED,MAAa,uBAAwB,SAAQ,KAAK;IAE9C,YAAY,OAAe,EAAkB,IAAiC;QAC1E,KAAK,CAAC,OAAO,CAAC,CAAC;QAD0B,SAAI,GAAJ,IAAI,CAA6B;QAE1E,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,uBAAuB,CAAC,SAAS,CAAC,CAAC;IACnE,CAAC;CACJ;AAND,0DAMC;AAED,SAAgB,6BAA6B,CAAC,KAAqB,EAAE,IAAiC;IAClG,MAAM,aAAa,GAAG,IAAI,uBAAuB,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,CAAC;IAC1E,6BAA6B,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;IAEnD,OAAO,aAAa,CAAC;AACzB,CAAC;AALD,sEAKC;AAED,SAAgB,6BAA6B,CAAC,KAAa;IACvD,IAAI,CAAC,KAAK,EAAE;QACR,OAAO,6BAA6B,CAAC,eAAe,EAAE,2BAA2B,CAAC,OAAO,CAAC,CAAC,CAAC,mDAAmD;KAClJ;IAED,OAAO,KAAK,CAAC;AACjB,CAAC;AAND,sEAMC;AAEY,0BAAkB,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;AA8J/D,SAAgB,mBAAmB,CAAC,QAA4B;IAC5D,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,wBAAwC,CAAC,CAAC;AAC7E,CAAC;AAFD,kDAEC;AAkBD,SAAgB,mBAAmB,CAAC,QAA4B;IAC5D,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,wBAAwC,CAAC,CAAC;AAC7E,CAAC;AAFD,kDAEC;AAwBD,SAAgB,sBAAsB,CAAC,QAA4B;IAC/D,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,wBAA+C,CAAC,CAAC;AACpF,CAAC;AAFD,wDAEC;AAgBD,SAAgB,2BAA2B,CAAC,QAA4B;IACpE,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,yBAAgD,CAAC,CAAC;AACrF,CAAC;AAFD,kEAEC;AA8CD,SAAgB,+BAA+B,CAAC,QAA4B;IACxE,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,iCAAwD,CAAC,CAAC;AAC7F,CAAC;AAFD,0EAEC;AAgBD,SAAgB,2BAA2B,CAAC,QAA4B;IACpE,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,0BAAgD,CAAC,CAAC;AACrF,CAAC;AAFD,kEAEC;AAED,SAAgB,6BAA6B,CAAC,KAAY,EAAE,IAAiC;IACzF,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,oBAAoB,CAAC,CAAC,CAAC,iBAAiB,CAAC;IAEpE,OAAO,KAAK,CAAC;AACjB,CAAC;AAJD,sEAIC;AAED,SAAgB,6BAA6B,CAAC,KAA+B;IAEzE,sBAAsB;IACtB,IAAI,CAAC,KAAK,EAAE;QACR,OAAO,2BAA2B,CAAC,OAAO,CAAC;KAC9C;IAED,8CAA8C;IAC9C,IAAI,KAAK,YAAY,uBAAuB,EAAE;QAC1C,OAAO,KAAK,CAAC,IAAI,CAAC;KACrB;IAED,mEAAmE;IACnE,0DAA0D;IAC1D,MAAM,KAAK,GAAG,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC5D,IAAI,CAAC,KAAK,EAAE;QACR,OAAO,2BAA2B,CAAC,OAAO,CAAC;KAC9C;IAED,QAAQ,KAAK,CAAC,CAAC,CAAC,EAAE;QACd,KAAK,2BAA2B,CAAC,UAAU,CAAC,CAAC,OAAO,2BAA2B,CAAC,UAAU,CAAC;QAC3F,KAAK,2BAA2B,CAAC,gBAAgB,CAAC,CAAC,OAAO,2BAA2B,CAAC,gBAAgB,CAAC;QACvG,KAAK,2BAA2B,CAAC,iBAAiB,CAAC,CAAC,OAAO,2BAA2B,CAAC,iBAAiB,CAAC;QACzG,KAAK,2BAA2B,CAAC,YAAY,CAAC,CAAC,OAAO,2BAA2B,CAAC,YAAY,CAAC;QAC/F,KAAK,2BAA2B,CAAC,sBAAsB,CAAC,CAAC,OAAO,2BAA2B,CAAC,sBAAsB,CAAC;QACnH,KAAK,2BAA2B,CAAC,YAAY,CAAC,CAAC,OAAO,2BAA2B,CAAC,YAAY,CAAC;QAC/F,KAAK,2BAA2B,CAAC,aAAa,CAAC,CAAC,OAAO,2BAA2B,CAAC,aAAa,CAAC;QACjG,KAAK,2BAA2B,CAAC,WAAW,CAAC,CAAC,OAAO,2BAA2B,CAAC,WAAW,CAAC;KAChG;IAED,OAAO,2BAA2B,CAAC,OAAO,CAAC;AAC/C,CAAC;AA/BD,sEA+BC;AAED,SAAgB,qBAAqB,CAAC,KAAY;IAE9C,wDAAwD;IACxD,IAAI,KAAK,YAAY,kBAAkB,EAAE;QACrC,OAAO,KAAK,CAAC,mBAAmB,CAAC;KACpC;IAED,kCAAkC;IAClC,QAAQ,6BAA6B,CAAC,KAAK,CAAC,EAAE;QAC1C,KAAK,2BAA2B,CAAC,YAAY;YACzC,8BAA0C;QAC9C,KAAK,2BAA2B,CAAC,gBAAgB;YAC7C,iCAA6C;QACjD,KAAK,2BAA2B,CAAC,iBAAiB;YAC9C,mCAA8C;QAClD,KAAK,2BAA2B,CAAC,aAAa;YAC1C,sCAAkD;QACtD,KAAK,2BAA2B,CAAC,UAAU;YACvC,kCAA8C;QAClD,KAAK,2BAA2B,CAAC,sBAAsB;YACnD,yCAAqD;QACzD,KAAK,2BAA2B,CAAC,YAAY;YACzC,8BAA0C;QAC9C;YACI,iCAA4C;KACnD;AACL,CAAC;AA1BD,sDA0BC;AAED;;GAEG;AACU,qBAAa,GAAG,EAAE,CAAC;AAIhC,SAAgB,IAAI,CAAC,IAA6D;IAC9E,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,EAAE;QACjE,OAAO,SAAS,CAAC;KACpB;IAED,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AAC5D,CAAC;AAND,oBAMC;AACD;;GAEG;AACH,MAAa,UAAU;IAMnB,MAAM,CAAC,UAAU,CAAC,IAAY;QAC1B,IAAI,IAAI,GAAG,UAAU,CAAC,EAAE,EAAE;YACtB,OAAO,IAAI,GAAG,GAAG,CAAC;SACrB;QACD,IAAI,IAAI,GAAG,UAAU,CAAC,EAAE,EAAE;YACtB,OAAO,CAAC,IAAI,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACnD;QACD,IAAI,IAAI,GAAG,UAAU,CAAC,EAAE,EAAE;YACtB,OAAO,CAAC,IAAI,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACnD;QACD,IAAI,IAAI,GAAG,UAAU,CAAC,EAAE,EAAE;YACtB,OAAO,CAAC,IAAI,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACnD;QACD,OAAO,CAAC,IAAI,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;IACpD,CAAC;;AApBL,gCAqBC;AApBmB,aAAE,GAAG,IAAI,CAAC;AACV,aAAE,GAAG,UAAU,CAAC,EAAE,GAAG,UAAU,CAAC,EAAE,CAAC;AACnC,aAAE,GAAG,UAAU,CAAC,EAAE,GAAG,UAAU,CAAC,EAAE,CAAC;AACnC,aAAE,GAAG,UAAU,CAAC,EAAE,GAAG,UAAU,CAAC,EAAE,CAAC;;;;;;;;;;;;;AC36BvD;;;;;;;;;;;;;;kFAckF;;;AAKlF,IAAiB,eAAe,CAqB/B;AArBD,WAAiB,eAAe;IAE5B;;;;;;;OAOG;IACH,SAAgB,yBAAyB,CAAC,SAAc,EAAE,MAAgB,EAAE,IAAY,EAAE,MAAc,EAAE;QACtG,MAAM,QAAQ,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,QAAS,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAEvF,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,CAAC;QACtB,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,EAAE;YACrD,KAAK,GAAG,KAAK,GAAG,CAAC,CAAC;YAClB,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,KAAK,GAAG,GAAG,CAAC;SACnC;QACD,OAAO,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC;IAVe,yCAAyB,4BAUxC;AACL,CAAC,EArBgB,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAqB/B;;;;;;;;;;;;;ACxCD;;;;;;;;;;;;;;kFAckF;AAClF;;;gGAGgG;AAChG,gIAAgI;;;AAKhI,+HAA8D;AAC9D,gJAA+F;AAC/F,4GAA+L;AAgB/L;;GAEG;AACI,KAAK,UAAU,kBAAkB,CACpC,QAA4D,EAC5D,QAAa,EACb,MAA0B,EAC1B,WAA6C,EAC7C,OAAgC,EAChC,KAAwB;IAExB,IAAI,KAAK,GAAsB,SAAS,CAAC;IAEzC,IAAI;QACA,MAAM,oBAAoB,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;KACvF;IAAC,OAAO,GAAG,EAAE;QACV,KAAK,GAAG,GAAG,CAAC;KACf;YAAS;QACN,IAAI,KAAK,IAAI,OAAO,CAAC,gBAAgB,EAAE;YACnC,KAAK,GAAG,OAAO,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;SAC3C;QAED,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;KACrB;AACL,CAAC;AArBD,gDAqBC;AAED,KAAK,UAAU,oBAAoB,CAAI,QAA4D,EAAE,QAAa,EAAE,MAA0B,EAAE,WAA6C,EAAE,OAAgC,EAAE,KAAwB;IAErP,yBAAyB;IACzB,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAExB,+BAA+B;IAC/B,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;IAEhE,yBAAyB;IACzB,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAExB,IAAI;QACA,IAAI,cAAc,GAAG,CAAC,CAAC;QACvB,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,qBAAqB,GAAG,CAAC,OAAO,IAAI,OAAO,OAAO,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC;QAEzG,IAAI,MAAM,GAAG,qBAAY,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,qBAAqB,KAAK,QAAQ,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;QAEtJ,IAAI,SAAS,GAAG,OAAO,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QACvF,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,GAAG;YACC,8EAA8E;YAC9E,kFAAkF;YAClF,SAAS,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,EAAE,MAAM,CAAC,UAAU,GAAG,WAAW,CAAC,CAAC;YAEhH,SAAS,IAAI,SAAS,CAAC;YACvB,WAAW,IAAI,SAAS,CAAC;YACzB,cAAc,IAAI,SAAS,CAAC;YAE5B,IAAI,OAAO,qBAAqB,KAAK,QAAQ,EAAE;gBAC3C,qBAAqB,IAAI,SAAS,CAAC;aACtC;YAED,gEAAgE;YAChE,IAAI,WAAW,KAAK,MAAM,CAAC,UAAU,EAAE;gBACnC,MAAM,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;gBAExC,MAAM,GAAG,qBAAY,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,qBAAqB,KAAK,QAAQ,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;gBAElJ,WAAW,GAAG,CAAC,CAAC;aACnB;SACJ,QAAQ,SAAS,GAAG,CAAC,IAAI,CAAC,OAAO,qBAAqB,KAAK,QAAQ,IAAI,qBAAqB,GAAG,CAAC,CAAC,IAAI,gBAAgB,CAAC,KAAK,CAAC,IAAI,eAAe,CAAC,cAAc,EAAE,OAAO,CAAC,EAAE;QAE3K,+DAA+D;QAC/D,IAAI,WAAW,GAAG,CAAC,EAAE;YACjB,IAAI,eAAe,GAAG,WAAW,CAAC;YAClC,IAAI,OAAO,qBAAqB,KAAK,QAAQ,EAAE;gBAC3C,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,qBAAqB,CAAC,CAAC;aAClE;YAED,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,CAAC;SAC/D;KACJ;IAAC,OAAO,KAAK,EAAE;QACZ,MAAM,qCAA6B,CAAC,KAAK,CAAC,CAAC;KAC9C;YAAS;QACN,MAAM,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;KAChC;AACL,CAAC;AAED,SAAS,gBAAgB,CAAC,KAAwB;IAC9C,IAAI,KAAK,CAAC,uBAAuB,EAAE;QAC/B,MAAM,wBAAQ,EAAE,CAAC;KACpB;IAED,OAAO,IAAI,CAAC;AAChB,CAAC;AAED,SAAS,eAAe,CAAC,cAAsB,EAAE,OAAgC;IAE7E,0EAA0E;IAC1E,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,EAAE;QACjB,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,QAAQ,IAAI,cAAc,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;YACrF,MAAM,qCAA6B,CAAC,kFAAkF,EAAE,mCAA2B,CAAC,sBAAsB,CAAC,CAAC;SAC/K;QAED,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,QAAQ,IAAI,cAAc,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE;YACjF,MAAM,qCAA6B,CAAC,2BAA2B,EAAE,mCAA2B,CAAC,YAAY,CAAC,CAAC;SAC9G;KACJ;IAED,OAAO,IAAI,CAAC;AAChB,CAAC","file":"vendors-node_modules_theia_filesystem_lib_browser_file-service_js.bundle.js","sourcesContent":["module.exports = require('@theia/application-package/lib/environment');\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/fileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/textfile/browser/textFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/textfile/electron-browser/nativeTextFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/workingCopy/common/workingCopyFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/workingCopy/common/workingCopyFileOperationParticipant.ts\n\n/* eslint-disable max-len */\n/* eslint-disable @typescript-eslint/no-shadow */\n/* eslint-disable no-null/no-null */\n/* eslint-disable @typescript-eslint/tslint/config */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { injectable, inject, named, postConstruct } from '@theia/core/shared/inversify';\nimport URI from '@theia/core/lib/common/uri';\nimport { timeout, Deferred } from '@theia/core/lib/common/promise-util';\nimport { CancellationToken, CancellationTokenSource } from '@theia/core/lib/common/cancellation';\nimport { Disposable, DisposableCollection } from '@theia/core/lib/common/disposable';\nimport { WaitUntilEvent, Emitter, AsyncEmitter } from '@theia/core/lib/common/event';\nimport { ContributionProvider } from '@theia/core/lib/common/contribution-provider';\nimport { TernarySearchTree } from '@theia/core/lib/common/ternary-search-tree';\nimport {\n    ensureFileSystemProviderError, etag, ETAG_DISABLED,\n    FileChangesEvent,\n    FileOperation, FileOperationError,\n    FileOperationEvent, FileOperationResult, FileSystemProviderCapabilities,\n    FileSystemProviderErrorCode, FileType, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, hasReadWriteCapability,\n    CreateFileOptions, FileContent, FileStat, FileStatWithMetadata,\n    FileStreamContent, FileSystemProvider,\n    FileSystemProviderWithFileReadWriteCapability, FileSystemProviderWithOpenReadWriteCloseCapability,\n    ReadFileOptions, ResolveFileOptions, ResolveMetadataFileOptions,\n    Stat, WatchOptions, WriteFileOptions,\n    toFileOperationResult, toFileSystemProviderErrorCode,\n    ResolveFileResult, ResolveFileResultWithMetadata,\n    MoveFileOptions, CopyFileOptions, BaseStatWithMetadata, FileDeleteOptions, FileOperationOptions, hasAccessCapability, hasUpdateCapability,\n    hasFileReadStreamCapability, FileSystemProviderWithFileReadStreamCapability\n} from '../common/files';\nimport { BinaryBuffer, BinaryBufferReadable, BinaryBufferReadableStream, BinaryBufferReadableBufferedStream, BinaryBufferWriteableStream } from '@theia/core/lib/common/buffer';\nimport { ReadableStream, isReadableStream, isReadableBufferedStream, transform, consumeStream, peekStream, peekReadable, Readable } from '@theia/core/lib/common/stream';\nimport { LabelProvider } from '@theia/core/lib/browser/label-provider';\nimport { FileSystemPreferences } from './filesystem-preferences';\nimport { ProgressService } from '@theia/core/lib/common/progress-service';\nimport { DelegatingFileSystemProvider } from '../common/delegating-file-system-provider';\nimport type { TextDocumentContentChangeEvent } from '@theia/core/shared/vscode-languageserver-protocol';\nimport { EncodingRegistry } from '@theia/core/lib/browser/encoding-registry';\nimport { UTF8, UTF8_with_bom } from '@theia/core/lib/common/encodings';\nimport { EncodingService, ResourceEncoding, DecodeStreamResult } from '@theia/core/lib/common/encoding-service';\nimport { Mutable } from '@theia/core/lib/common/types';\nimport { readFileIntoStream } from '../common/io';\nimport { FileSystemWatcherErrorHandler } from './filesystem-watcher-error-handler';\nimport { FileSystemUtils } from '../common/filesystem-utils';\n\nexport interface FileOperationParticipant {\n\n    /**\n     * Participate in a file operation of a working copy. Allows to\n     * change the working copy before it is being saved to disk.\n     */\n    participate(\n        target: URI,\n        source: URI | undefined,\n        operation: FileOperation,\n        timeout: number,\n        token: CancellationToken\n    ): Promise<void>;\n}\n\nexport interface ReadEncodingOptions {\n\n    /**\n     * The optional encoding parameter allows to specify the desired encoding when resolving\n     * the contents of the file.\n     */\n    encoding?: string;\n\n    /**\n     * The optional guessEncoding parameter allows to guess encoding from content of the file.\n     */\n    autoGuessEncoding?: boolean;\n}\n\nexport interface WriteEncodingOptions {\n\n    /**\n     * The encoding to use when updating a file.\n     */\n    encoding?: string;\n\n    /**\n     * If set to true, will enforce the selected encoding and not perform any detection using BOMs.\n     */\n    overwriteEncoding?: boolean;\n}\n\nexport interface ReadTextFileOptions extends ReadEncodingOptions, ReadFileOptions {\n    /**\n     * The optional acceptTextOnly parameter allows to fail this request early if the file\n     * contents are not textual.\n     */\n    acceptTextOnly?: boolean;\n}\n\ninterface BaseTextFileContent extends BaseStatWithMetadata {\n\n    /**\n     * The encoding of the content if known.\n     */\n    encoding: string;\n}\n\nexport interface TextFileContent extends BaseTextFileContent {\n\n    /**\n     * The content of a text file.\n     */\n    value: string;\n}\n\nexport interface TextFileStreamContent extends BaseTextFileContent {\n\n    /**\n     * The line grouped content of a text file.\n     */\n    value: ReadableStream<string>;\n}\n\nexport interface CreateTextFileOptions extends WriteEncodingOptions, CreateFileOptions { }\n\nexport interface WriteTextFileOptions extends WriteEncodingOptions, WriteFileOptions { }\n\nexport interface UpdateTextFileOptions extends WriteEncodingOptions, WriteFileOptions {\n    readEncoding: string\n}\n\nexport interface UserFileOperationEvent extends WaitUntilEvent {\n\n    /**\n     * An identifier to correlate the operation through the\n     * different event types (before, after, error).\n     */\n    readonly correlationId: number;\n\n    /**\n     * The file operation that is taking place.\n     */\n    readonly operation: FileOperation;\n\n    /**\n     * The resource the event is about.\n     */\n    readonly target: URI;\n\n    /**\n     * A property that is defined for move operations.\n     */\n    readonly source?: URI;\n}\n\nexport const FileServiceContribution = Symbol('FileServiceContribution');\n\n/**\n * A {@link FileServiceContribution} can be used to add custom {@link FileSystemProvider}s.\n * For this, the contribution has to listen to the {@link FileSystemProviderActivationEvent} and register\n * the custom {@link FileSystemProvider}s according to the scheme when this event is fired.\n *\n * ### Example usage\n * ```ts\n * export class MyFileServiceContribution implements FileServiceContribution {\n *     registerFileSystemProviders(service: FileService): void {\n *         service.onWillActivateFileSystemProvider(event => {\n *             if (event.scheme === 'mySyncProviderScheme') {\n *                 service.registerProvider('mySyncProviderScheme', this.mySyncProvider);\n *             }\n *             if (event.scheme === 'myAsyncProviderScheme') {\n *                 event.waitUntil((async () => {\n *                     const myAsyncProvider = await this.createAsyncProvider();\n *                     service.registerProvider('myAsyncProviderScheme', myAsyncProvider);\n *                 })());\n *             }\n *         });\n *\n *     }\n *```\n */\nexport interface FileServiceContribution {\n    /**\n     * Register custom file system providers for the given {@link FileService}.\n     * @param service The file service for which the providers should be registered.\n     */\n    registerFileSystemProviders(service: FileService): void;\n}\n\n/**\n * Represents the `FileSystemProviderRegistration` event.\n * This event is fired by the {@link FileService} if a {@link FileSystemProvider} is\n * registered to or unregistered from the service.\n */\nexport interface FileSystemProviderRegistrationEvent {\n    /** `True` if a new provider has been registered, `false` if a provider has been unregistered. */\n    added: boolean;\n    /** The (uri) scheme for which the provider was (previously) registered */\n    scheme: string;\n    /** The affected file system provider for which this event was fired. */\n    provider?: FileSystemProvider;\n}\n\n/**\n * Represents the `FileSystemProviderCapabilitiesChange` event.\n * This event is fired by the {@link FileService} if the capabilities of one of its managed\n * {@link FileSystemProvider}s have changed.\n */\nexport interface FileSystemProviderCapabilitiesChangeEvent {\n    /** The affected file system provider for which this event was fired. */\n    provider: FileSystemProvider;\n    /** The (uri) scheme for which the provider is registered */\n    scheme: string;\n}\n\n/**\n * Represents the `FileSystemProviderActivation` event.\n * This event is fired by the {@link FileService} if it wants to activate the\n * {@link FileSystemProvider} for a specific scheme.\n */\nexport interface FileSystemProviderActivationEvent extends WaitUntilEvent {\n    /** The (uri) scheme for which the provider should be activated */\n    scheme: string;\n}\n\nexport const enum TextFileOperationResult {\n    FILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n    constructor(\n        message: string,\n        public textFileOperationResult: TextFileOperationResult,\n        public options?: ReadTextFileOptions & WriteTextFileOptions\n    ) {\n        super(message, FileOperationResult.FILE_OTHER_ERROR);\n        Object.setPrototypeOf(this, TextFileOperationError.prototype);\n    }\n\n}\n\n/**\n * The {@link FileService} is the common facade responsible for all interactions with file systems.\n * It manages all registered {@link FileSystemProvider}s and\n *  forwards calls to the responsible {@link FileSystemProvider}, determined by the scheme.\n * For additional documentation regarding the provided functions see also {@link FileSystemProvider}.\n */\n@injectable()\nexport class FileService {\n\n    private readonly BUFFER_SIZE = 64 * 1024;\n\n    @inject(LabelProvider)\n    protected readonly labelProvider: LabelProvider;\n\n    @inject(FileSystemPreferences)\n    protected readonly preferences: FileSystemPreferences;\n\n    @inject(ProgressService)\n    protected readonly progressService: ProgressService;\n\n    @inject(EncodingRegistry)\n    protected readonly encodingRegistry: EncodingRegistry;\n\n    @inject(EncodingService)\n    protected readonly encodingService: EncodingService;\n\n    @inject(ContributionProvider) @named(FileServiceContribution)\n    protected readonly contributions: ContributionProvider<FileServiceContribution>;\n\n    @inject(FileSystemWatcherErrorHandler)\n    protected readonly watcherErrorHandler: FileSystemWatcherErrorHandler;\n\n    @postConstruct()\n    protected init(): void {\n        for (const contribution of this.contributions.getContributions()) {\n            contribution.registerFileSystemProviders(this);\n        }\n    }\n\n    // #region Events\n\n    private correlationIds = 0;\n\n    private readonly onWillRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is being performed.\n     * This event is triggered by user gestures.\n     */\n    readonly onWillRunUserOperation = this.onWillRunUserOperationEmitter.event;\n\n    private readonly onDidFailUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is failed.\n     * This event is triggered by user gestures.\n     */\n    readonly onDidFailUserOperation = this.onDidFailUserOperationEmitter.event;\n\n    private readonly onDidRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is finished.\n     * This event is triggered by user gestures.\n     */\n    readonly onDidRunUserOperation = this.onDidRunUserOperationEmitter.event;\n\n    // #endregion\n\n    // #region File System Provider\n\n    private onDidChangeFileSystemProviderRegistrationsEmitter = new Emitter<FileSystemProviderRegistrationEvent>();\n    readonly onDidChangeFileSystemProviderRegistrations = this.onDidChangeFileSystemProviderRegistrationsEmitter.event;\n\n    private onWillActivateFileSystemProviderEmitter = new Emitter<FileSystemProviderActivationEvent>();\n    /**\n     * See `FileServiceContribution.registerProviders`.\n     */\n    readonly onWillActivateFileSystemProvider = this.onWillActivateFileSystemProviderEmitter.event;\n\n    private onDidChangeFileSystemProviderCapabilitiesEmitter = new Emitter<FileSystemProviderCapabilitiesChangeEvent>();\n    readonly onDidChangeFileSystemProviderCapabilities = this.onDidChangeFileSystemProviderCapabilitiesEmitter.event;\n\n    private readonly providers = new Map<string, FileSystemProvider>();\n    private readonly activations = new Map<string, Promise<FileSystemProvider>>();\n\n    /**\n     * Registers a new {@link FileSystemProvider} for the given scheme.\n     * @param scheme The (uri) scheme for which the provider should be registered.\n     * @param provider The file system provider that should be registered.\n     *\n     * @returns A `Disposable` that can be invoked to unregister the given provider.\n     */\n    registerProvider(scheme: string, provider: FileSystemProvider): Disposable {\n        if (this.providers.has(scheme)) {\n            throw new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n        }\n\n        this.providers.set(scheme, provider);\n        this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({ added: true, scheme, provider });\n\n        const providerDisposables = new DisposableCollection();\n        providerDisposables.push(provider.onDidChangeFile(changes => this.onDidFilesChangeEmitter.fire(new FileChangesEvent(changes))));\n        providerDisposables.push(provider.onFileWatchError(() => this.handleFileWatchError()));\n        providerDisposables.push(provider.onDidChangeCapabilities(() => this.onDidChangeFileSystemProviderCapabilitiesEmitter.fire({ provider, scheme })));\n\n        return Disposable.create(() => {\n            this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({ added: false, scheme, provider });\n            this.providers.delete(scheme);\n\n            providerDisposables.dispose();\n        });\n    }\n\n    /**\n     * Try to activate the registered provider for the given scheme\n     * @param scheme  The uri scheme for which the responsible provider should be activated.\n     *\n     * @returns A promise of the activated file system provider. Only resolves if a provider is available for this scheme, gets rejected otherwise.\n     */\n    async activateProvider(scheme: string): Promise<FileSystemProvider> {\n        let provider = this.providers.get(scheme);\n        if (provider) {\n            return provider;\n        }\n        let activation = this.activations.get(scheme);\n        if (!activation) {\n            const deferredActivation = new Deferred<FileSystemProvider>();\n            this.activations.set(scheme, activation = deferredActivation.promise);\n            WaitUntilEvent.fire(this.onWillActivateFileSystemProviderEmitter, { scheme }).then(() => {\n                provider = this.providers.get(scheme);\n                if (!provider) {\n                    const error = new Error();\n                    error.name = 'ENOPRO';\n                    error.message = `No file system provider found for scheme ${scheme}`;\n                    throw error;\n                } else {\n                    deferredActivation.resolve(provider);\n                }\n            }).catch(e => deferredActivation.reject(e));\n        }\n        return activation;\n    }\n\n    /**\n     * Tests if the service (i.e. any of its registered {@link FileSystemProvider}s) can handle the given resource.\n     * @param resource `URI` of the resource to test.\n     *\n     * @returns `true` if the resource can be handled, `false` otherwise.\n     */\n    canHandleResource(resource: URI): boolean {\n        return this.providers.has(resource.scheme);\n    }\n\n    /**\n     * Tests if the service (i.e the {@link FileSystemProvider} registered for the given uri scheme) provides the given capability.\n     * @param resource `URI` of the resource to test.\n     * @param capability The required capability.\n     *\n     * @returns `true` if the resource can be handled and the required capability can be provided.\n     */\n    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n        const provider = this.providers.get(resource.scheme);\n\n        return !!(provider && (provider.capabilities & capability));\n    }\n\n    protected async withProvider(resource: URI): Promise<FileSystemProvider> {\n        // Assert path is absolute\n        if (!resource.path.isAbsolute) {\n            throw new FileOperationError(`Unable to resolve filesystem provider with relative file path ${this.resourceForError(resource)}`, FileOperationResult.FILE_INVALID_PATH);\n        }\n\n        return this.activateProvider(resource.scheme);\n    }\n\n    private async withReadProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\n        const provider = await this.withProvider(resource);\n\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n            return provider;\n        }\n\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n    }\n\n    private async withWriteProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\n        const provider = await this.withProvider(resource);\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n            return provider;\n        }\n\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n    }\n\n    // #endregion\n\n    private onDidRunOperationEmitter = new Emitter<FileOperationEvent>();\n    /**\n     * An event that is emitted when operation is finished.\n     * This event is triggered by user gestures and programmatically.\n     */\n    readonly onDidRunOperation = this.onDidRunOperationEmitter.event;\n\n    /**\n     * Try to resolve file information and metadata for the given resource.\n     * @param resource `URI` of the resource that should be resolved.\n     * @param options  Options to customize the resolvement process.\n     *\n     * @return A promise that resolves if the resource could be successfully resolved.\n     */\n    resolve(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\n    resolve(resource: URI, options?: ResolveFileOptions | undefined): Promise<FileStat>;\n    async resolve(resource: any, options?: any) {\n        try {\n            return await this.doResolveFile(resource, options);\n        } catch (error) {\n\n            // Specially handle file not found case as file operation result\n            if (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n                throw new FileOperationError(`Unable to resolve non-existing file '${this.resourceForError(resource)}'`, FileOperationResult.FILE_NOT_FOUND);\n            }\n\n            // Bubble up any other error as is\n            throw ensureFileSystemProviderError(error);\n        }\n    }\n\n    private async doResolveFile(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat>;\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat> {\n        const provider = await this.withProvider(resource);\n\n        const resolveTo = options?.resolveTo;\n        const resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n        const resolveMetadata = options?.resolveMetadata;\n\n        const stat = await provider.stat(resource);\n\n        let trie: TernarySearchTree<URI, boolean> | undefined;\n\n        return this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n            // lazy trie to check for recursive resolving\n            if (!trie) {\n                trie = TernarySearchTree.forUris<true>(!!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive));\n                trie.set(resource, true);\n                if (Array.isArray(resolveTo) && resolveTo.length) {\n                    resolveTo.forEach(uri => trie!.set(uri, true));\n                }\n            }\n\n            // check for recursive resolving\n            if (Boolean(trie.findSuperstr(stat.resource) || trie.get(stat.resource))) {\n                return true;\n            }\n\n            // check for resolving single child folders\n            if (stat.isDirectory && resolveSingleChildDescendants) {\n                return siblings === 1;\n            }\n\n            return false;\n        });\n    }\n\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat>;\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStatWithMetadata>;\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat> {\n        const fileStat = FileStat.fromStat(resource, stat);\n\n        // check to recurse for directories\n        if (fileStat.isDirectory && recurse(fileStat, siblings)) {\n            try {\n                const entries = await provider.readdir(resource);\n                const resolvedEntries = await Promise.all(entries.map(async ([name, type]) => {\n                    try {\n                        const childResource = resource.resolve(name);\n                        const childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n                        return await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n                    } catch (error) {\n                        console.trace(error);\n\n                        return null; // can happen e.g. due to permission errors\n                    }\n                }));\n\n                // make sure to get rid of null values that signal a failure to resolve a particular entry\n                fileStat.children = resolvedEntries.filter(e => !!e) as FileStat[];\n            } catch (error) {\n                console.trace(error);\n\n                fileStat.children = []; // gracefully handle errors, we may not have permissions to read\n            }\n\n            return fileStat;\n        }\n\n        return fileStat;\n    }\n\n    /**\n     * Try to resolve file information and metadata for all given resource.\n     * @param toResolve An array of all the resources (and corresponding resolvement options) that should be resolved.\n     *\n     * @returns A promise of all resolved resources. The promise is not rejected if any of the given resources cannot be resolved.\n     * Instead this is reflected with the `success` flag of the corresponding {@link ResolveFileResult}.\n     */\n    async resolveAll(toResolve: { resource: URI, options?: ResolveFileOptions }[]): Promise<ResolveFileResult[]>;\n    async resolveAll(toResolve: { resource: URI, options: ResolveMetadataFileOptions }[]): Promise<ResolveFileResultWithMetadata[]>;\n    async resolveAll(toResolve: { resource: URI; options?: ResolveFileOptions; }[]): Promise<ResolveFileResult[]> {\n        return Promise.all(toResolve.map(async entry => {\n            try {\n                return { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n            } catch (error) {\n                console.trace(error);\n\n                return { stat: undefined, success: false };\n            }\n        }));\n    }\n\n    /**\n     * Tests if the given resource exists in the filesystem.\n     * @param resource `URI` of the resource which should be tested.\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\n     *\n     * @returns A promise that resolves to `true` if the resource exists.\n     */\n    async exists(resource: URI): Promise<boolean> {\n        const provider = await this.withProvider(resource);\n\n        try {\n            const stat = await provider.stat(resource);\n\n            return !!stat;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests a user's permissions for the given resource.\n     */\n    async access(resource: URI, mode?: number): Promise<boolean> {\n        const provider = await this.withProvider(resource);\n\n        if (!hasAccessCapability(provider)) {\n            return false;\n        }\n        try {\n            await provider.access(resource, mode);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Resolves the fs path of the given URI.\n     *\n     * USE WITH CAUTION: You should always prefer URIs to paths if possible, as they are\n     * portable and platform independent. Paths should only be used in cases you directly\n     * interact with the OS, e.g. when running a command on the shell.\n     *\n     * If you need to display human readable simple or long names then use `LabelProvider` instead.\n     * @param resource `URI` of the resource that should be resolved.\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\n     *\n     * @returns A promise of the resolved fs path.\n     */\n    async fsPath(resource: URI): Promise<string> {\n        const provider = await this.withProvider(resource);\n\n        if (!hasAccessCapability(provider)) {\n            return resource.path.toString();\n        }\n        return provider.fsPath(resource);\n    }\n\n    // #region Text File Reading/Writing\n\n    async create(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doCreate(resource, value, options);\n        }\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.CREATE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.CREATE, target: resource };\n        await this.onWillRunUserOperationEmitter.fire(event);\n\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doCreate(resource, value, options);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n\n        return stat;\n    }\n\n    protected async doCreate(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\n        const encoding = await this.getWriteEncoding(resource, options);\n        const encoded = await this.encodingService.encodeStream(value, encoding);\n        return this.createFile(resource, encoded, options);\n    }\n\n    async write(resource: URI, value: string | Readable<string>, options?: WriteTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\n        const encoding = await this.getWriteEncoding(resource, options);\n        const encoded = await this.encodingService.encodeStream(value, encoding);\n        return Object.assign(await this.writeFile(resource, encoded, options), { encoding: encoding.encoding });\n    }\n\n    async read(resource: URI, options?: ReadTextFileOptions): Promise<TextFileContent> {\n        const [bufferStream, decoder] = await this.doRead(resource, {\n            ...options,\n            // optimization: since we know that the caller does not\n            // care about buffering, we indicate this to the reader.\n            // this reduces all the overhead the buffered reading\n            // has (open, read, close) if the provider supports\n            // unbuffered reading.\n            preferUnbuffered: true\n        });\n\n        return {\n            ...bufferStream,\n            encoding: decoder.detected.encoding || UTF8,\n            value: await consumeStream(decoder.stream, strings => strings.join(''))\n        };\n    }\n\n    async readStream(resource: URI, options?: ReadTextFileOptions): Promise<TextFileStreamContent> {\n        const [bufferStream, decoder] = await this.doRead(resource, options);\n\n        return {\n            ...bufferStream,\n            encoding: decoder.detected.encoding || UTF8,\n            value: decoder.stream\n        };\n    }\n\n    private async doRead(resource: URI, options?: ReadTextFileOptions & { preferUnbuffered?: boolean }): Promise<[FileStreamContent, DecodeStreamResult]> {\n        options = this.resolveReadOptions(options);\n\n        // read stream raw (either buffered or unbuffered)\n        let bufferStream: FileStreamContent;\n        if (options?.preferUnbuffered) {\n            const content = await this.readFile(resource, options);\n            bufferStream = {\n                ...content,\n                value: BinaryBufferReadableStream.fromBuffer(content.value)\n            };\n        } else {\n            bufferStream = await this.readFileStream(resource, options);\n        }\n\n        const decoder = await this.encodingService.decodeStream(bufferStream.value, {\n            guessEncoding: options.autoGuessEncoding,\n            overwriteEncoding: detectedEncoding => this.getReadEncoding(resource, options, detectedEncoding)\n        });\n\n        // validate binary\n        if (options?.acceptTextOnly && decoder.detected.seemsBinary) {\n            throw new TextFileOperationError('File seems to be binary and cannot be opened as text', TextFileOperationResult.FILE_IS_BINARY, options);\n        }\n\n        return [bufferStream, decoder];\n    }\n\n    protected resolveReadOptions(options?: ReadTextFileOptions): ReadTextFileOptions {\n        options = {\n            ...options,\n            autoGuessEncoding: typeof options?.autoGuessEncoding === 'boolean' ? options.autoGuessEncoding : this.preferences['files.autoGuessEncoding']\n        };\n        const limits: Mutable<ReadTextFileOptions['limits']> = options.limits = options.limits || {};\n        if (typeof limits.size !== 'number') {\n            limits.size = this.preferences['files.maxFileSizeMB'] * 1024 * 1024;\n        }\n        return options;\n    }\n\n    async update(resource: URI, changes: TextDocumentContentChangeEvent[], options: UpdateTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n        try {\n            await this.validateWriteFile(provider, resource, options);\n            if (hasUpdateCapability(provider)) {\n                const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);;\n                const stat = await provider.updateFile(resource, changes, {\n                    readEncoding: options.readEncoding,\n                    writeEncoding: encoding,\n                    overwriteEncoding: options.overwriteEncoding || false\n                });\n                return Object.assign(FileStat.fromStat(resource, stat), { encoding: stat.encoding });\n            } else {\n                throw new Error('incremental file update is not supported');\n            }\n        } catch (error) {\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\n        }\n    }\n\n    // #endregion\n\n    // #region File Reading/Writing\n\n    async createFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream = BinaryBuffer.fromString(''), options?: CreateFileOptions): Promise<FileStatWithMetadata> {\n\n        // validate overwrite\n        if (!options?.overwrite && await this.exists(resource)) {\n            throw new FileOperationError(`Unable to create file '${this.resourceForError(resource)}' that already exists when overwrite flag is not set`, FileOperationResult.FILE_MODIFIED_SINCE, options);\n        }\n\n        // do write into file (this will create it too)\n        const fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n        // events\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n        return fileStat;\n    }\n\n    async writeFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream, options?: WriteFileOptions): Promise<FileStatWithMetadata> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\n        try {\n\n            // validate write\n            const stat = await this.validateWriteFile(provider, resource, options);\n\n            // mkdir recursively as needed\n            if (!stat) {\n                await this.mkdirp(provider, resource.parent);\n            }\n\n            // optimization: if the provider has unbuffered write capability and the data\n            // to write is a Readable, we consume up to 3 chunks and try to write the data\n            // unbuffered to reduce the overhead. If the Readable has more data to provide\n            // we continue to write buffered.\n            let bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream;\n            if (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof BinaryBuffer)) {\n                if (isReadableStream(bufferOrReadableOrStream)) {\n                    const bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n                    if (bufferedStream.ended) {\n                        bufferOrReadableOrStreamOrBufferedStream = BinaryBuffer.concat(bufferedStream.buffer);\n                    } else {\n                        bufferOrReadableOrStreamOrBufferedStream = bufferedStream;\n                    }\n                } else {\n                    bufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => BinaryBuffer.concat(data), 3);\n                }\n            } else {\n                bufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\n            }\n\n            // write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\n            if (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer)) {\n                await this.doWriteUnbuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream);\n            }\n\n            // write file: buffered\n            else {\n                await this.doWriteBuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer ? BinaryBufferReadable.fromBuffer(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\n            }\n        } catch (error) {\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\n        }\n\n        return this.resolve(resource, { resolveMetadata: true });\n    }\n\n    private async validateWriteFile(provider: FileSystemProvider, resource: URI, options?: WriteFileOptions): Promise<Stat | undefined> {\n        let stat: Stat | undefined = undefined;\n        try {\n            stat = await provider.stat(resource);\n        } catch (error) {\n            return undefined; // file might not exist\n        }\n\n        // file cannot be directory\n        if ((stat.type & FileType.Directory) !== 0) {\n            throw new FileOperationError(`Unable to write file ${this.resourceForError(resource)} that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\n        }\n\n        if (this.modifiedSince(stat, options)) {\n            throw new FileOperationError('File Modified Since', FileOperationResult.FILE_MODIFIED_SINCE, options);\n        }\n\n        return stat;\n    }\n\n    /**\n     * Dirty write prevention: if the file on disk has been changed and does not match our expected\n     * mtime and etag, we bail out to prevent dirty writing.\n     *\n     * First, we check for a mtime that is in the future before we do more checks. The assumption is\n     * that only the mtime is an indicator for a file that has changed on disk.\n     *\n     * Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n     * one using the etag() function. Relying only on the mtime check has proven to produce false\n     * positives due to file system weirdness (especially around remote file systems). As such, the\n     * check for size is a weaker check because it can return a false negative if the file has changed\n     * but to the same length. This is a compromise we take to avoid having to produce checksums of\n     * the file content for comparison which would be much slower to compute.\n     */\n    protected modifiedSince(stat: Stat, options?: WriteFileOptions): boolean {\n        return !!options && typeof options.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n            typeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n            options.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size });\n    }\n\n    async readFile(resource: URI, options?: ReadFileOptions): Promise<FileContent> {\n        const provider = await this.withReadProvider(resource);\n\n        const stream = await this.doReadAsFileStream(provider, resource, {\n            ...options,\n            // optimization: since we know that the caller does not\n            // care about buffering, we indicate this to the reader.\n            // this reduces all the overhead the buffered reading\n            // has (open, read, close) if the provider supports\n            // unbuffered reading.\n            preferUnbuffered: true\n        });\n\n        return {\n            ...stream,\n            value: await BinaryBufferReadableStream.toBuffer(stream.value)\n        };\n    }\n\n    async readFileStream(resource: URI, options?: ReadFileOptions): Promise<FileStreamContent> {\n        const provider = await this.withReadProvider(resource);\n\n        return this.doReadAsFileStream(provider, resource, options);\n    }\n\n    private async doReadAsFileStream(provider: FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options?: ReadFileOptions & { preferUnbuffered?: boolean }): Promise<FileStreamContent> {\n\n        // install a cancellation token that gets cancelled\n        // when any error occurs. this allows us to resolve\n        // the content of the file while resolving metadata\n        // but still cancel the operation in certain cases.\n        const cancellableSource = new CancellationTokenSource();\n\n        // validate read operation\n        const statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\n            cancellableSource.cancel();\n\n            throw error;\n        });\n\n        try {\n\n            // if the etag is provided, we await the result of the validation\n            // due to the likelyhood of hitting a NOT_MODIFIED_SINCE result.\n            // otherwise, we let it run in parallel to the file reading for\n            // optimal startup performance.\n            if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED) {\n                await statPromise;\n            }\n\n            let fileStreamPromise: Promise<BinaryBufferReadableStream>;\n\n            // read unbuffered (only if either preferred, or the provider has no buffered read capability)\n            if (!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || (hasReadWriteCapability(provider) && options?.preferUnbuffered)) {\n                fileStreamPromise = this.readFileUnbuffered(provider, resource, options);\n            }\n\n            // read streamed (always prefer over primitive buffered read)\n            else if (hasFileReadStreamCapability(provider)) {\n                fileStreamPromise = Promise.resolve(this.readFileStreamed(provider, resource, cancellableSource.token, options));\n            }\n\n            // read buffered\n            else {\n                fileStreamPromise = Promise.resolve(this.readFileBuffered(provider, resource, cancellableSource.token, options));\n            }\n\n            const [fileStat, fileStream] = await Promise.all([statPromise, fileStreamPromise]);\n\n            return {\n                ...fileStat,\n                value: fileStream\n            };\n        } catch (error) {\n            this.rethrowAsFileOperationError('Unable to read file', resource, error, options);\n        }\n    }\n\n    private readFileStreamed(provider: FileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\n        const fileStream = provider.readFileStream(resource, options, token);\n\n        return transform(fileStream, {\n            data: data => data instanceof BinaryBuffer ? data : BinaryBuffer.wrap(data),\n            error: error => this.asFileOperationError('Unable to read file', resource, error, options)\n        }, data => BinaryBuffer.concat(data));\n    }\n\n    private readFileBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\n        const stream = BinaryBufferWriteableStream.create();\n\n        readFileIntoStream(provider, resource, stream, data => data, {\n            ...options,\n            bufferSize: this.BUFFER_SIZE,\n            errorTransformer: error => this.asFileOperationError('Unable to read file', resource, error, options)\n        }, token);\n\n        return stream;\n    }\n\n    protected rethrowAsFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): never {\n        throw this.asFileOperationError(message, resource, error, options);\n    }\n    protected asFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): FileOperationError {\n        const fileOperationError = new FileOperationError(`${message} '${this.resourceForError(resource)}' (${ensureFileSystemProviderError(error).toString()})`,\n            toFileOperationResult(error), options);\n        fileOperationError.stack = `${fileOperationError.stack}\\nCaused by: ${error.stack}`;\n        return fileOperationError;\n    }\n\n    private async readFileUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, options?: ReadFileOptions): Promise<BinaryBufferReadableStream> {\n        let buffer = await provider.readFile(resource);\n\n        // respect position option\n        if (options && typeof options.position === 'number') {\n            buffer = buffer.slice(options.position);\n        }\n\n        // respect length option\n        if (options && typeof options.length === 'number') {\n            buffer = buffer.slice(0, options.length);\n        }\n\n        // Throw if file is too large to load\n        this.validateReadFileLimits(resource, buffer.byteLength, options);\n\n        return BinaryBufferReadableStream.fromBuffer(BinaryBuffer.wrap(buffer));\n    }\n\n    private async validateReadFile(resource: URI, options?: ReadFileOptions): Promise<FileStatWithMetadata> {\n        const stat = await this.resolve(resource, { resolveMetadata: true });\n\n        // Throw if resource is a directory\n        if (stat.isDirectory) {\n            throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\n        }\n\n        // Throw if file not modified since (unless disabled)\n        if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n            throw new FileOperationError('File not modified since', FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n        }\n\n        // Throw if file is too large to load\n        this.validateReadFileLimits(resource, stat.size, options);\n\n        return stat;\n    }\n\n    private validateReadFileLimits(resource: URI, size: number, options?: ReadFileOptions): void {\n        if (options?.limits) {\n            let tooLargeErrorResult: FileOperationResult | undefined = undefined;\n\n            if (typeof options.limits.memory === 'number' && size > options.limits.memory) {\n                tooLargeErrorResult = FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n            }\n\n            if (typeof options.limits.size === 'number' && size > options.limits.size) {\n                tooLargeErrorResult = FileOperationResult.FILE_TOO_LARGE;\n            }\n\n            if (typeof tooLargeErrorResult === 'number') {\n                throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is too large to open`, tooLargeErrorResult);\n            }\n        }\n    }\n\n    // #endregion\n\n    // #region Move/Copy/Delete/Create Folder\n\n    async move(source: URI, target: URI, options?: MoveFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doMove(source, target, options.overwrite);\n        }\n        await this.runFileOperationParticipants(target, source, FileOperation.MOVE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.MOVE, target, source };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doMove(source, target, options?.overwrite);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n        return stat;\n    }\n\n    protected async doMove(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\n        const sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n        // move\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n        // resolve and send events\n        const fileStat = await this.resolve(target, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n        return fileStat;\n    }\n\n    async copy(source: URI, target: URI, options?: CopyFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doCopy(source, target, options.overwrite);\n        }\n        await this.runFileOperationParticipants(target, source, FileOperation.COPY);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.COPY, target, source };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doCopy(source, target, options?.overwrite);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n        return stat;\n    }\n\n    protected async doCopy(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\n        const sourceProvider = await this.withReadProvider(source);\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n        // copy\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n        // resolve and send events\n        const fileStat = await this.resolve(target, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n        return fileStat;\n    }\n\n    private async doMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n        if (source.toString() === target.toString()) {\n            return mode; // simulate node.js behaviour here and do a no-op if paths match\n        }\n\n        // validation\n        const { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n        // if target exists get valid target\n        if (exists && !overwrite) {\n            const parent = await this.resolve(target.parent);\n            const name = isSameResourceWithDifferentPathCase ? target.path.name : target.path.name + '_copy';\n            target = FileSystemUtils.generateUniqueResourceURI(target.parent, parent, name, target.path.ext);\n        }\n\n        // delete as needed (unless target is same resource with different path case)\n        if (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n            await this.delete(target, { recursive: true });\n        }\n\n        // create parent folders\n        await this.mkdirp(targetProvider, target.parent);\n\n        // copy source => target\n        if (mode === 'copy') {\n\n            // same provider with fast copy: leverage copy() functionality\n            if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n                await sourceProvider.copy(source, target, { overwrite });\n            }\n\n            // when copying via buffer/unbuffered, we have to manually\n            // traverse the source if it is a folder and not a file\n            else {\n                const sourceFile = await this.resolve(source);\n                if (sourceFile.isDirectory) {\n                    await this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n                } else {\n                    await this.doCopyFile(sourceProvider, source, targetProvider, target);\n                }\n            }\n\n            return mode;\n        }\n\n        // move source => target\n        else {\n\n            // same provider: leverage rename() functionality\n            if (sourceProvider === targetProvider) {\n                await sourceProvider.rename(source, target, { overwrite });\n\n                return mode;\n            }\n\n            // across providers: copy to target & delete at source\n            else {\n                await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\n                await this.delete(source, { recursive: true });\n\n                return 'copy';\n            }\n        }\n    }\n\n    private async doCopyFile(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI): Promise<void> {\n\n        // copy: source (buffered) => target (buffered)\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n            return this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (buffered) => target (unbuffered)\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n            return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (unbuffered) => target (buffered)\n        if (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n            return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (unbuffered) => target (unbuffered)\n        if (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n            return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n        }\n    }\n\n    private async doCopyFolder(sourceProvider: FileSystemProvider, sourceFolder: FileStat, targetProvider: FileSystemProvider, targetFolder: URI): Promise<void> {\n\n        // create folder in target\n        await targetProvider.mkdir(targetFolder);\n\n        // create children in target\n        if (Array.isArray(sourceFolder.children)) {\n            await Promise.all(sourceFolder.children.map(async sourceChild => {\n                const targetChild = targetFolder.resolve(sourceChild.name);\n                if (sourceChild.isDirectory) {\n                    return this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n                } else {\n                    return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n                }\n            }));\n        }\n    }\n\n    private async doValidateMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean, isSameResourceWithDifferentPathCase: boolean }> {\n        let isSameResourceWithDifferentPathCase = false;\n\n        // Check if source is equal or parent to target (requires providers to be the same)\n        if (sourceProvider === targetProvider) {\n            const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n            if (!isPathCaseSensitive) {\n                isSameResourceWithDifferentPathCase = source.toString().toLowerCase() === target.toString().toLowerCase();\n            }\n\n            if (isSameResourceWithDifferentPathCase && mode === 'copy') {\n                throw new Error(`Unable to copy when source '${this.resourceForError(source)}' is same as target '${this.resourceForError(target)}' with different path case on a case insensitive file system`);\n            }\n\n            if (!isSameResourceWithDifferentPathCase && target.isEqualOrParent(source, isPathCaseSensitive)) {\n                throw new Error(`Unable to move/copy when source '${this.resourceForError(source)}' is parent of target '${this.resourceForError(target)}'.`);\n            }\n        }\n\n        // Extra checks if target exists and this is not a rename\n        const exists = await this.exists(target);\n        if (exists && !isSameResourceWithDifferentPathCase) {\n\n            // Special case: if the target is a parent of the source, we cannot delete\n            // it as it would delete the source as well. In this case we have to throw\n            if (sourceProvider === targetProvider) {\n                const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n                if (source.isEqualOrParent(target, isPathCaseSensitive)) {\n                    throw new Error(`Unable to move/copy '${this.resourceForError(source)}' into '${this.resourceForError(target)}' since a file would replace the folder it is contained in.`);\n                }\n            }\n        }\n\n        return { exists, isSameResourceWithDifferentPathCase };\n    }\n\n    async createFolder(resource: URI): Promise<FileStatWithMetadata> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n        // mkdir recursively\n        await this.mkdirp(provider, resource);\n\n        // events\n        const fileStat = await this.resolve(resource, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n        return fileStat;\n    }\n\n    private async mkdirp(provider: FileSystemProvider, directory: URI): Promise<void> {\n        const directoriesToCreate: string[] = [];\n\n        // mkdir until we reach root\n        while (!directory.path.isRoot) {\n            try {\n                const stat = await provider.stat(directory);\n                if ((stat.type & FileType.Directory) === 0) {\n                    throw new Error(`Unable to create folder ${this.resourceForError(directory)} that already exists but is not a directory`);\n                }\n\n                break; // we have hit a directory that exists -> good\n            } catch (error) {\n\n                // Bubble up any other error that is not file not found\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n                    throw error;\n                }\n\n                // Upon error, remember directories that need to be created\n                directoriesToCreate.push(directory.path.base);\n\n                // Continue up\n                directory = directory.parent;\n            }\n        }\n\n        // Create directories as needed\n        for (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n            directory = directory.resolve(directoriesToCreate[i]);\n\n            try {\n                await provider.mkdir(directory);\n            } catch (error) {\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n                    // For mkdirp() we tolerate that the mkdir() call fails\n                    // in case the folder already exists. This follows node.js\n                    // own implementation of fs.mkdir({ recursive: true }) and\n                    // reduces the chances of race conditions leading to errors\n                    // if multiple calls try to create the same folders\n                    // As such, we only throw an error here if it is other than\n                    // the fact that the file already exists.\n                    // (see also https://github.com/microsoft/vscode/issues/89834)\n                    throw error;\n                }\n            }\n        }\n    }\n\n    async delete(resource: URI, options?: FileOperationOptions & Partial<FileDeleteOptions>): Promise<void> {\n        if (options?.fromUserGesture === false) {\n            return this.doDelete(resource, options);\n        }\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.DELETE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.DELETE, target: resource };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        try {\n            await this.doDelete(resource, options);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n    }\n\n    protected async doDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<void> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n        // Validate trash support\n        const useTrash = !!options?.useTrash;\n        if (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n            throw new Error(`Unable to delete file '${this.resourceForError(resource)}' via trash because provider does not support it.`);\n        }\n\n        // Validate delete\n        const exists = await this.exists(resource);\n        if (!exists) {\n            throw new FileOperationError(`Unable to delete non-existing file '${this.resourceForError(resource)}'`, FileOperationResult.FILE_NOT_FOUND);\n        }\n\n        // Validate recursive\n        const recursive = !!options?.recursive;\n        if (!recursive && exists) {\n            const stat = await this.resolve(resource);\n            if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n                throw new Error(`Unable to delete non-empty folder '${this.resourceForError(resource)}'.`);\n            }\n        }\n\n        // Delete through provider\n        await provider.delete(resource, { recursive, useTrash });\n\n        // Events\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n    }\n\n    // #endregion\n\n    // #region File Watching\n\n    private onDidFilesChangeEmitter = new Emitter<FileChangesEvent>();\n    /**\n     * An event that is emitted when files are changed on the disk.\n     */\n    readonly onDidFilesChange = this.onDidFilesChangeEmitter.event;\n\n    private activeWatchers = new Map<string, { disposable: Disposable, count: number }>();\n\n    watch(resource: URI, options: WatchOptions = { recursive: false, excludes: [] }): Disposable {\n        const resolvedOptions: WatchOptions = {\n            ...options,\n            // always ignore temporary upload files\n            excludes: options.excludes.concat('**/theia_upload_*')\n        };\n\n        let watchDisposed = false;\n        let watchDisposable = Disposable.create(() => watchDisposed = true);\n\n        // Watch and wire in disposable which is async but\n        // check if we got disposed meanwhile and forward\n        this.doWatch(resource, resolvedOptions).then(disposable => {\n            if (watchDisposed) {\n                disposable.dispose();\n            } else {\n                watchDisposable = disposable;\n            }\n        }, error => console.error(error));\n\n        return Disposable.create(() => watchDisposable.dispose());\n    }\n\n    async doWatch(resource: URI, options: WatchOptions): Promise<Disposable> {\n        const provider = await this.withProvider(resource);\n        const key = this.toWatchKey(provider, resource, options);\n\n        // Only start watching if we are the first for the given key\n        const watcher = this.activeWatchers.get(key) || { count: 0, disposable: provider.watch(resource, options) };\n        if (!this.activeWatchers.has(key)) {\n            this.activeWatchers.set(key, watcher);\n        }\n\n        // Increment usage counter\n        watcher.count += 1;\n\n        return Disposable.create(() => {\n\n            // Unref\n            watcher.count--;\n\n            // Dispose only when last user is reached\n            if (watcher.count === 0) {\n                watcher.disposable.dispose();\n                this.activeWatchers.delete(key);\n            }\n        });\n    }\n\n    private toWatchKey(provider: FileSystemProvider, resource: URI, options: WatchOptions): string {\n        return [\n            this.toMapKey(provider, resource),  // lowercase path if the provider is case insensitive\n            String(options.recursive),          // use recursive: true | false as part of the key\n            options.excludes.join()             // use excludes as part of the key\n        ].join();\n    }\n\n    // #endregion\n\n    // #region Helpers\n\n    private writeQueues: Map<string, Promise<void>> = new Map();\n\n    private ensureWriteQueue(provider: FileSystemProvider, resource: URI, task: () => Promise<void>): Promise<void> {\n        // ensure to never write to the same resource without finishing\n        // the one write. this ensures a write finishes consistently\n        // (even with error) before another write is done.\n        const queueKey = this.toMapKey(provider, resource);\n        const writeQueue = (this.writeQueues.get(queueKey) || Promise.resolve()).then(task, task);\n        this.writeQueues.set(queueKey, writeQueue);\n        return writeQueue;\n    }\n\n    private toMapKey(provider: FileSystemProvider, resource: URI): string {\n        const isPathCaseSensitive = !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\n        return isPathCaseSensitive ? resource.toString() : resource.toString().toLowerCase();\n    }\n\n    private async doWriteBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, readableOrStreamOrBufferedStream: BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        return this.ensureWriteQueue(provider, resource, async () => {\n\n            // open handle\n            const handle = await provider.open(resource, { create: true });\n\n            // write into handle until all bytes from buffer have been written\n            try {\n                if (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n                    await this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n                } else {\n                    await this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n                }\n            } catch (error) {\n                throw ensureFileSystemProviderError(error);\n            } finally {\n\n                // close handle always\n                await provider.close(handle);\n            }\n        });\n    }\n\n    private async doWriteStreamBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        let posInFile = 0;\n        let stream: BinaryBufferReadableStream;\n\n        // Buffered stream: consume the buffer first by writing\n        // it to the target before reading from the stream.\n        if (isReadableBufferedStream(streamOrBufferedStream)) {\n            if (streamOrBufferedStream.buffer.length > 0) {\n                const chunk = BinaryBuffer.concat(streamOrBufferedStream.buffer);\n                await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n                posInFile += chunk.byteLength;\n            }\n\n            // If the stream has been consumed, return early\n            if (streamOrBufferedStream.ended) {\n                return;\n            }\n\n            stream = streamOrBufferedStream.stream;\n        }\n\n        // Unbuffered stream - just take as is\n        else {\n            stream = streamOrBufferedStream;\n        }\n\n        return new Promise(async (resolve, reject) => {\n\n            stream.on('data', async chunk => {\n\n                // pause stream to perform async write operation\n                stream.pause();\n\n                try {\n                    await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n                } catch (error) {\n                    return reject(error);\n                }\n\n                posInFile += chunk.byteLength;\n\n                // resume stream now that we have successfully written\n                // run this on the next tick to prevent increasing the\n                // execution stack because resume() may call the event\n                // handler again before finishing.\n                setTimeout(() => stream.resume());\n            });\n\n            stream.on('error', error => reject(error));\n            stream.on('end', () => resolve());\n        });\n    }\n\n    private async doWriteReadableBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: BinaryBufferReadable): Promise<void> {\n        let posInFile = 0;\n\n        let chunk: BinaryBuffer | null;\n        while ((chunk = readable.read()) !== null) {\n            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n            posInFile += chunk.byteLength;\n        }\n    }\n\n    private async doWriteBuffer(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: BinaryBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n        let totalBytesWritten = 0;\n        while (totalBytesWritten < length) {\n            const bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n            totalBytesWritten += bytesWritten;\n        }\n    }\n\n    private async doWriteUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        return this.ensureWriteQueue(provider, resource, () => this.doWriteUnbufferedQueued(provider, resource, bufferOrReadableOrStreamOrBufferedStream));\n    }\n\n    private async doWriteUnbufferedQueued(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        let buffer: BinaryBuffer;\n        if (bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer) {\n            buffer = bufferOrReadableOrStreamOrBufferedStream;\n        } else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n            buffer = await BinaryBufferReadableStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        } else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n            buffer = await BinaryBufferReadableBufferedStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        } else {\n            buffer = BinaryBufferReadable.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        }\n\n        return provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true });\n    }\n\n    private async doPipeBuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeBufferedQueued(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        let sourceHandle: number | undefined = undefined;\n        let targetHandle: number | undefined = undefined;\n\n        try {\n\n            // Open handles\n            sourceHandle = await sourceProvider.open(source, { create: false });\n            targetHandle = await targetProvider.open(target, { create: true });\n\n            const buffer = BinaryBuffer.alloc(this.BUFFER_SIZE);\n\n            let posInFile = 0;\n            let posInBuffer = 0;\n            let bytesRead = 0;\n            do {\n                // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n                // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n                bytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n                // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n                // buffer position (posInBuffer) all bytes we read (bytesRead).\n                await this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n                posInFile += bytesRead;\n                posInBuffer += bytesRead;\n\n                // when buffer full, fill it again from the beginning\n                if (posInBuffer === buffer.byteLength) {\n                    posInBuffer = 0;\n                }\n            } while (bytesRead > 0);\n        } catch (error) {\n            throw ensureFileSystemProviderError(error);\n        } finally {\n            await Promise.all([\n                typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n                typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n            ]);\n        }\n    }\n\n    private async doPipeUnbuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeUnbufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n        return targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true });\n    }\n\n    private async doPipeUnbufferedToBuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeUnbufferedToBufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n        // Open handle\n        const targetHandle = await targetProvider.open(target, { create: true });\n\n        // Read entire buffer from source and write buffered\n        try {\n            const buffer = await sourceProvider.readFile(source);\n            await this.doWriteBuffer(targetProvider, targetHandle, BinaryBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n        } catch (error) {\n            throw ensureFileSystemProviderError(error);\n        } finally {\n            await targetProvider.close(targetHandle);\n        }\n    }\n\n    private async doPipeBufferedToUnbuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n        // Read buffer via stream buffered\n        const buffer = await BinaryBufferReadableStream.toBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n        // Write buffer into target at once\n        await this.doWriteUnbuffered(targetProvider, target, buffer);\n    }\n\n    protected throwIfFileSystemIsReadonly<T extends FileSystemProvider>(provider: T, resource: URI): T {\n        if (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n            throw new FileOperationError(`Unable to modify readonly file ${this.resourceForError(resource)}`, FileOperationResult.FILE_PERMISSION_DENIED);\n        }\n\n        return provider;\n    }\n\n    private resourceForError(resource: URI): string {\n        return this.labelProvider.getLongName(resource);\n    }\n\n    // #endregion\n\n    // #region File operation participants\n\n    private readonly participants: FileOperationParticipant[] = [];\n\n    addFileOperationParticipant(participant: FileOperationParticipant): Disposable {\n        this.participants.push(participant);\n\n        return Disposable.create(() => {\n            const index = this.participants.indexOf(participant);\n            if (index > -1) {\n                this.participants.splice(index, 1);\n            }\n        });\n    }\n\n    async runFileOperationParticipants(target: URI, source: URI | undefined, operation: FileOperation): Promise<void> {\n        const participantsTimeout = this.preferences['files.participants.timeout'];\n        if (participantsTimeout <= 0) {\n            return;\n        }\n\n        const cancellationTokenSource = new CancellationTokenSource();\n\n        return this.progressService.withProgress(this.progressLabel(operation), 'window', async () => {\n            for (const participant of this.participants) {\n                if (cancellationTokenSource.token.isCancellationRequested) {\n                    break;\n                }\n\n                try {\n                    const promise = participant.participate(target, source, operation, participantsTimeout, cancellationTokenSource.token);\n                    await Promise.race([\n                        promise,\n                        timeout(participantsTimeout, cancellationTokenSource.token).then(() => cancellationTokenSource.dispose(), () => { /* no-op if cancelled */ })\n                    ]);\n                } catch (err) {\n                    console.warn(err);\n                }\n            }\n        });\n    }\n\n    private progressLabel(operation: FileOperation): string {\n        switch (operation) {\n            case FileOperation.CREATE:\n                return \"Running 'File Create' participants...\";\n            case FileOperation.MOVE:\n                return \"Running 'File Rename' participants...\";\n            case FileOperation.COPY:\n                return \"Running 'File Copy' participants...\";\n            case FileOperation.DELETE:\n                return \"Running 'File Delete' participants...\";\n        }\n    }\n\n    // #endregion\n\n    // #region encoding\n\n    protected async getWriteEncoding(resource: URI, options?: WriteEncodingOptions): Promise<ResourceEncoding> {\n        const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);\n        return this.encodingService.toResourceEncoding(encoding, {\n            overwriteEncoding: options?.overwriteEncoding,\n            read: async length => {\n                const buffer = await BinaryBufferReadableStream.toBuffer((await this.readFileStream(resource, { length })).value);\n                return buffer.buffer;\n            }\n        });\n    }\n\n    protected getReadEncoding(resource: URI, options?: ReadEncodingOptions, detectedEncoding?: string): Promise<string> {\n        let preferredEncoding: string | undefined;\n\n        // Encoding passed in as option\n        if (options?.encoding) {\n            if (detectedEncoding === UTF8_with_bom && options.encoding === UTF8) {\n                preferredEncoding = UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8\n            } else {\n                preferredEncoding = options.encoding; // give passed in encoding highest priority\n            }\n        } else if (detectedEncoding) {\n            preferredEncoding = detectedEncoding;\n        }\n\n        return this.getEncodingForResource(resource, preferredEncoding);\n    }\n\n    protected async getEncodingForResource(resource: URI, preferredEncoding?: string): Promise<string> {\n        resource = await this.toUnderlyingResource(resource);\n        return this.encodingRegistry.getEncodingForResource(resource, preferredEncoding);\n    }\n\n    /**\n     * Converts to an underlying fs provider resource format.\n     *\n     * For example converting `user-storage` resources to `file` resources under a user home:\n     * user-storage:/user/settings.json => file://home/.theia/settings.json\n     */\n    async toUnderlyingResource(resource: URI): Promise<URI> {\n        let provider = await this.withProvider(resource);\n        while (provider instanceof DelegatingFileSystemProvider) {\n            resource = provider.toUnderlyingResource(resource);\n            provider = await this.withProvider(resource);\n        }\n        return resource;\n    }\n\n    // #endregion\n\n    protected handleFileWatchError(): void {\n        this.watcherErrorHandler.handleError();\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { interfaces } from '@theia/core/shared/inversify';\nimport {\n    createPreferenceProxy,\n    PreferenceProxy,\n    PreferenceService,\n    PreferenceSchema,\n    PreferenceContribution\n} from '@theia/core/lib/browser/preferences';\nimport { SUPPORTED_ENCODINGS } from '@theia/core/lib/browser/supported-encodings';\n\n// See https://github.com/Microsoft/vscode/issues/30180\nexport const WIN32_MAX_FILE_SIZE_MB = 300; // 300 MB\nexport const GENERAL_MAX_FILE_SIZE_MB = 16 * 1024; // 16 GB\n\nexport const MAX_FILE_SIZE_MB = typeof process === 'object'\n    ? process.arch === 'ia32'\n        ? WIN32_MAX_FILE_SIZE_MB\n        : GENERAL_MAX_FILE_SIZE_MB\n    : 32;\n\nexport const filesystemPreferenceSchema: PreferenceSchema = {\n    type: 'object',\n    properties: {\n        'files.watcherExclude': {\n            description: 'List of paths to exclude from the filesystem watcher',\n            additionalProperties: {\n                type: 'boolean'\n            },\n            default: {\n                '**/.git/objects/**': true,\n                '**/.git/subtree-cache/**': true,\n                '**/node_modules/**': true\n            },\n            scope: 'resource'\n        },\n        'files.exclude': {\n            type: 'object',\n            default: { '**/.git': true, '**/.svn': true, '**/.hg': true, '**/CVS': true, '**/.DS_Store': true },\n            description: 'Configure glob patterns for excluding files and folders.',\n            scope: 'resource'\n        },\n        'files.enableTrash': {\n            type: 'boolean',\n            default: true,\n            description: 'Moves files/folders to the OS trash (recycle bin on Windows) when deleting. Disabling this will delete files/folders permanently.'\n        },\n        'files.associations': {\n            type: 'object',\n            description: 'Configure file associations to languages (e.g. \\\"*.extension\\\": \\\"html\\\"). \\\nThese have precedence over the default associations of the languages installed.'\n        },\n        'files.autoGuessEncoding': {\n            type: 'boolean',\n            default: false,\n            description: 'When enabled, the editor will attempt to guess the character set encoding when opening files. This setting can also be configured per language.',\n            scope: 'language-overridable',\n            included: Object.keys(SUPPORTED_ENCODINGS).length > 1\n        },\n        'files.participants.timeout': {\n            type: 'number',\n            default: 5000,\n            markdownDescription: 'Timeout in milliseconds after which file participants for create, rename, and delete are cancelled. Use `0` to disable participants.'\n        },\n        'files.maxFileSizeMB': {\n            type: 'number',\n            default: MAX_FILE_SIZE_MB,\n            markdownDescription: 'Controls the max file size in MB which is possible to open.'\n        },\n        'files.trimTrailingWhitespace': {\n            type: 'boolean',\n            default: false,\n            description: 'When enabled, will trim trailing whitespace when saving a file.',\n            scope: 'language-overridable'\n        },\n        'files.maxConcurrentUploads': {\n            type: 'integer',\n            default: 1,\n            description: 'Maximum number of concurrent files to upload when uploading multiple files. 0 means all files will be uploaded concurrently.',\n        }\n    }\n};\n\nexport interface FileSystemConfiguration {\n    'files.watcherExclude': { [globPattern: string]: boolean }\n    'files.exclude': { [key: string]: boolean }\n    'files.enableTrash': boolean\n    'files.associations': { [filepattern: string]: string }\n    'files.encoding': string\n    'files.autoGuessEncoding': boolean\n    'files.participants.timeout': number\n    'files.maxFileSizeMB': number\n    'files.trimTrailingWhitespace': boolean\n    'files.maxConcurrentUploads': number\n}\n\nexport const FileSystemPreferenceContribution = Symbol('FilesystemPreferenceContribution');\nexport const FileSystemPreferences = Symbol('FileSystemPreferences');\nexport type FileSystemPreferences = PreferenceProxy<FileSystemConfiguration>;\n\nexport function createFileSystemPreferences(preferences: PreferenceService, schema: PreferenceSchema = filesystemPreferenceSchema): FileSystemPreferences {\n    return createPreferenceProxy(preferences, schema);\n}\n\nexport function bindFileSystemPreferences(bind: interfaces.Bind): void {\n    bind(FileSystemPreferences).toDynamicValue(ctx => {\n        const preferences = ctx.container.get<PreferenceService>(PreferenceService);\n        const contribution = ctx.container.get<PreferenceContribution>(FileSystemPreferenceContribution);\n        return createFileSystemPreferences(preferences, contribution.schema);\n    }).inSingletonScope();\n    bind(FileSystemPreferenceContribution).toConstantValue({ schema: filesystemPreferenceSchema });\n    bind(PreferenceContribution).toService(FileSystemPreferenceContribution);\n}\n","/********************************************************************************\n * Copyright (C) 2020 Arm and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { injectable, inject } from '@theia/core/shared/inversify';\nimport { environment } from '@theia/core/shared/@theia/application-package/lib/environment';\nimport { MessageService } from '@theia/core';\nimport { WindowService } from '@theia/core/lib/browser/window/window-service';\n\n@injectable()\nexport class FileSystemWatcherErrorHandler {\n\n    @inject(MessageService) protected readonly messageService: MessageService;\n    @inject(WindowService) protected readonly windowService: WindowService;\n\n    protected watchHandlesExhausted: boolean = false;\n\n    protected get instructionsLink(): string {\n        return 'https://code.visualstudio.com/docs/setup/linux#_visual-studio-code-is-unable-to-watch-for-file-changes-in-this-large-workspace-error-enospc';\n    }\n\n    public async handleError(): Promise<void> {\n        if (!this.watchHandlesExhausted) {\n            this.watchHandlesExhausted = true;\n            if (this.isElectron()) {\n                const instructionsAction = 'Instructions';\n                const action = await this.messageService.warn(\n                    'Unable to watch for file changes in this large workspace.  Please follow the instructions link to resolve this issue.',\n                    { timeout: 60000 },\n                    instructionsAction\n                );\n                if (action === instructionsAction) {\n                    this.windowService.openNewWindow(this.instructionsLink, { external: true });\n                }\n            } else {\n                await this.messageService.warn(\n                    'Unable to watch for file changes in this large workspace.  The information you see may not include recent file changes.',\n                    { timeout: 60000 }\n                );\n            }\n        }\n    }\n\n    protected isElectron(): boolean {\n        return environment.electron.is();\n    }\n\n}\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport URI from '@theia/core/lib/common/uri';\nimport { Event, Emitter, CancellationToken } from '@theia/core/lib/common';\nimport { Disposable, DisposableCollection } from '@theia/core/lib/common/disposable';\nimport {\n    FileSystemProvider, FileSystemProviderCapabilities, WatchOptions, FileDeleteOptions, FileOverwriteOptions, FileWriteOptions, FileOpenOptions, FileChange, Stat, FileType,\n    hasReadWriteCapability, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, hasAccessCapability, FileUpdateOptions, hasUpdateCapability, FileUpdateResult,\n    FileReadStreamOptions,\n    hasFileReadStreamCapability\n} from './files';\nimport type { TextDocumentContentChangeEvent } from '@theia/core/shared/vscode-languageserver-protocol';\nimport { ReadableStreamEvents } from '@theia/core/lib/common/stream';\n\nexport class DelegatingFileSystemProvider implements Required<FileSystemProvider>, Disposable {\n\n    private readonly onDidChangeFileEmitter = new Emitter<readonly FileChange[]>();\n    readonly onDidChangeFile = this.onDidChangeFileEmitter.event;\n\n    private readonly onFileWatchErrorEmitter = new Emitter<void>();\n    readonly onFileWatchError = this.onFileWatchErrorEmitter.event;\n\n    constructor(\n        protected readonly delegate: FileSystemProvider,\n        protected readonly options: DelegatingFileSystemProvider.Options,\n        protected readonly toDispose = new DisposableCollection()\n    ) {\n        this.toDispose.push(this.onDidChangeFileEmitter);\n        this.toDispose.push(delegate.onDidChangeFile(changes => this.handleFileChanges(changes)));\n        this.toDispose.push(this.onFileWatchErrorEmitter);\n        this.toDispose.push(delegate.onFileWatchError(changes => this.onFileWatchErrorEmitter.fire()));\n    }\n\n    dispose(): void {\n        this.toDispose.dispose();\n    }\n\n    get capabilities(): FileSystemProviderCapabilities {\n        return this.delegate.capabilities;\n    }\n\n    get onDidChangeCapabilities(): Event<void> {\n        return this.delegate.onDidChangeCapabilities;\n    }\n\n    watch(resource: URI, opts: WatchOptions): Disposable {\n        return this.delegate.watch(this.toUnderlyingResource(resource), opts);\n    }\n\n    stat(resource: URI): Promise<Stat> {\n        return this.delegate.stat(this.toUnderlyingResource(resource));\n    }\n\n    access(resource: URI, mode?: number): Promise<void> {\n        if (hasAccessCapability(this.delegate)) {\n            return this.delegate.access(this.toUnderlyingResource(resource), mode);\n        }\n        throw new Error('not supported');\n    }\n\n    fsPath(resource: URI): Promise<string> {\n        if (hasAccessCapability(this.delegate)) {\n            return this.delegate.fsPath(this.toUnderlyingResource(resource));\n        }\n        throw new Error('not supported');\n    }\n\n    mkdir(resource: URI): Promise<void> {\n        return this.delegate.mkdir(this.toUnderlyingResource(resource));\n    }\n\n    rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n        return this.delegate.rename(this.toUnderlyingResource(from), this.toUnderlyingResource(to), opts);\n    }\n\n    copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n        if (hasFileFolderCopyCapability(this.delegate)) {\n            return this.delegate.copy(this.toUnderlyingResource(from), this.toUnderlyingResource(to), opts);\n        }\n        throw new Error('not supported');\n    }\n\n    readFile(resource: URI): Promise<Uint8Array> {\n        if (hasReadWriteCapability(this.delegate)) {\n            return this.delegate.readFile(this.toUnderlyingResource(resource));\n        }\n        throw new Error('not supported');\n    }\n\n    readFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n        if (hasFileReadStreamCapability(this.delegate)) {\n            return this.delegate.readFileStream(this.toUnderlyingResource(resource), opts, token);\n        }\n        throw new Error('not supported');\n    }\n\n    readdir(resource: URI): Promise<[string, FileType][]> {\n        return this.delegate.readdir(this.toUnderlyingResource(resource));\n    }\n\n    writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void> {\n        if (hasReadWriteCapability(this.delegate)) {\n            return this.delegate.writeFile(this.toUnderlyingResource(resource), content, opts);\n        }\n        throw new Error('not supported');\n    }\n\n    open(resource: URI, opts: FileOpenOptions): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.open(this.toUnderlyingResource(resource), opts);\n        }\n        throw new Error('not supported');\n    }\n\n    close(fd: number): Promise<void> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.close(fd);\n        }\n        throw new Error('not supported');\n    }\n\n    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.read(fd, pos, data, offset, length);\n        }\n        throw new Error('not supported');\n    }\n\n    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.write(fd, pos, data, offset, length);\n        }\n        throw new Error('not supported');\n    }\n\n    delete(resource: URI, opts: FileDeleteOptions): Promise<void> {\n        return this.delegate.delete(this.toUnderlyingResource(resource), opts);\n    }\n\n    updateFile(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult> {\n        if (hasUpdateCapability(this.delegate)) {\n            return this.delegate.updateFile(resource, changes, opts);\n        }\n        throw new Error('not supported');\n    }\n\n    protected handleFileChanges(changes: readonly FileChange[]): void {\n        const delegatingChanges: FileChange[] = [];\n        for (const change of changes) {\n            const delegatingResource = this.fromUnderlyingResource(change.resource);\n            if (delegatingResource) {\n                delegatingChanges.push({\n                    resource: delegatingResource,\n                    type: change.type\n                });\n            }\n        }\n        if (delegatingChanges.length) {\n            this.onDidChangeFileEmitter.fire(delegatingChanges);\n        }\n    }\n\n    /**\n     * Converts to an underlying fs provider resource format.\n     *\n     * For example converting `user-storage` resources to `file` resources under a user home:\n     * user-storage:/user/settings.json => file://home/.theia/settings.json\n     */\n    toUnderlyingResource(resource: URI): URI {\n        const underlying = this.options.uriConverter.to(resource);\n        if (!underlying) {\n            throw new Error('invalid resource: ' + resource.toString());\n        }\n        return underlying;\n    }\n\n    /**\n     * Converts from an underlying fs provider resource format.\n     *\n     * For example converting `file` resources under a user home to `user-storage` resource:\n     * - file://home/.theia/settings.json => user-storage:/user/settings.json\n     * - file://documents/some-document.txt => undefined\n     */\n    fromUnderlyingResource(resource: URI): URI | undefined {\n        return this.options.uriConverter.from(resource);\n    }\n\n}\nexport namespace DelegatingFileSystemProvider {\n    export interface Options {\n        uriConverter: URIConverter\n    }\n    export interface URIConverter {\n        /**\n         * Converts to an underlying fs provider resource format.\n         * Returns undefined if the given resource is not valid resource.\n         *\n         * For example converting `user-storage` resources to `file` resources under a user home:\n         * user-storage:/user/settings.json => file://home/.theia/settings.json\n         * user-storage:/settings.json => undefined\n         */\n        to(resource: URI): URI | undefined;\n        /**\n         * Converts from an underlying fs provider resource format.\n         *\n         * For example converting `file` resources under a user home to `user-storage` resource:\n         * - file://home/.theia/settings.json => user-storage:/settings.json\n         * - file://documents/some-document.txt => undefined\n         */\n        from(resource: URI): URI | undefined;\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/files.ts\n\nimport URI from '@theia/core/lib/common/uri';\nimport { Event } from '@theia/core/lib/common/event';\nimport { Disposable as IDisposable } from '@theia/core/lib/common/disposable';\nimport { BinaryBuffer, BinaryBufferReadableStream } from '@theia/core/lib/common/buffer';\nimport type { TextDocumentContentChangeEvent } from '@theia/core/shared/vscode-languageserver-protocol';\nimport { ReadableStreamEvents } from '@theia/core/lib/common/stream';\nimport { CancellationToken } from '@theia/core/lib/common/cancellation';\n\nexport const enum FileOperation {\n    CREATE,\n    DELETE,\n    MOVE,\n    COPY\n}\n\nexport class FileOperationEvent {\n\n    constructor(resource: URI, operation: FileOperation.DELETE);\n    constructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: FileStatWithMetadata);\n    constructor(public readonly resource: URI, public readonly operation: FileOperation, public readonly target?: FileStatWithMetadata) { }\n\n    isOperation(operation: FileOperation.DELETE): boolean;\n    isOperation(operation: FileOperation.MOVE | FileOperation.COPY | FileOperation.CREATE): this is { readonly target: FileStatWithMetadata };\n    isOperation(operation: FileOperation): boolean {\n        return this.operation === operation;\n    }\n}\n\n/**\n * Possible changes that can occur to a file.\n */\nexport const enum FileChangeType {\n    UPDATED = 0,\n    ADDED = 1,\n    DELETED = 2\n}\n\n/**\n * Identifies a single change in a file.\n */\nexport interface FileChange {\n\n    /**\n     * The type of change that occurred to the file.\n     */\n    readonly type: FileChangeType;\n\n    /**\n     * The unified resource identifier of the file that changed.\n     */\n    readonly resource: URI;\n}\n\nexport class FileChangesEvent {\n\n    constructor(public readonly changes: readonly FileChange[]) { }\n\n    /**\n     * Returns true if this change event contains the provided file with the given change type (if provided). In case of\n     * type DELETED, this method will also return true if a folder got deleted that is the parent of the\n     * provided file path.\n     */\n    contains(resource: URI, type?: FileChangeType): boolean {\n        if (!resource) {\n            return false;\n        }\n\n        const checkForChangeType = typeof type === 'number';\n\n        return this.changes.some(change => {\n            if (checkForChangeType && change.type !== type) {\n                return false;\n            }\n\n            // For deleted also return true when deleted folder is parent of target path\n            if (change.type === FileChangeType.DELETED) {\n                return resource.isEqualOrParent(change.resource);\n            }\n\n            return resource.toString() === change.resource.toString();\n        });\n    }\n\n    /**\n     * Returns the changes that describe added files.\n     */\n    getAdded(): FileChange[] {\n        return this.getOfType(FileChangeType.ADDED);\n    }\n\n    /**\n     * Returns if this event contains added files.\n     */\n    gotAdded(): boolean {\n        return this.hasType(FileChangeType.ADDED);\n    }\n\n    /**\n     * Returns the changes that describe deleted files.\n     */\n    getDeleted(): FileChange[] {\n        return this.getOfType(FileChangeType.DELETED);\n    }\n\n    /**\n     * Returns if this event contains deleted files.\n     */\n    gotDeleted(): boolean {\n        return this.hasType(FileChangeType.DELETED);\n    }\n\n    /**\n     * Returns the changes that describe updated files.\n     */\n    getUpdated(): FileChange[] {\n        return this.getOfType(FileChangeType.UPDATED);\n    }\n\n    /**\n     * Returns if this event contains updated files.\n     */\n    gotUpdated(): boolean {\n        return this.hasType(FileChangeType.UPDATED);\n    }\n\n    private getOfType(type: FileChangeType): FileChange[] {\n        return this.changes.filter(change => change.type === type);\n    }\n\n    private hasType(type: FileChangeType): boolean {\n        return this.changes.some(change => change.type === type);\n    }\n}\n\nexport interface BaseStat {\n\n    /**\n     * The unified resource identifier of this file or folder.\n     */\n    resource: URI;\n\n    /**\n     * The name which is the last segment\n     * of the {{path}}.\n     */\n    name: string;\n\n    /**\n     * The size of the file.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    size?: number;\n\n    /**\n     * The last modification date represented as millis from unix epoch.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    mtime?: number;\n\n    /**\n     * The creation date represented as millis from unix epoch.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    ctime?: number;\n\n    /**\n     * A unique identifier that represents the\n     * current state of the file or directory.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    etag?: string;\n}\nexport namespace BaseStat {\n    export function is(arg: Object | undefined): arg is BaseStat {\n        return !!arg && typeof arg === 'object'\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            && ('resource' in arg && <any>arg['resource'] instanceof URI)\n            && ('name' in arg && typeof arg['name'] === 'string');\n    }\n}\n\nexport interface BaseStatWithMetadata extends BaseStat {\n    mtime: number;\n    ctime: number;\n    etag: string;\n    size: number;\n}\n\n/**\n * A file resource with meta information.\n */\nexport interface FileStat extends BaseStat {\n\n    /**\n     * The resource is a file.\n     */\n    isFile: boolean;\n\n    /**\n     * The resource is a directory.\n     */\n    isDirectory: boolean;\n\n    /**\n     * The resource is a symbolic link.\n     */\n    isSymbolicLink: boolean;\n\n    /**\n     * The children of the file stat or undefined if none.\n     */\n    children?: FileStat[];\n}\nexport namespace FileStat {\n    export function is(arg: Object | undefined): arg is FileStat {\n        return BaseStat.is(arg) &&\n            ('isFile' in arg && typeof arg['isFile'] === 'boolean') &&\n            ('isDirectory' in arg && typeof arg['isDirectory'] === 'boolean') &&\n            ('isSymbolicLink' in arg && typeof arg['isSymbolicLink'] === 'boolean');\n    }\n    export function asFileType(stat: FileStat): FileType {\n        let res = 0;\n        if (stat.isFile) {\n            res += FileType.File;\n\n        } else if (stat.isDirectory) {\n            res += FileType.Directory;\n        }\n        if (stat.isSymbolicLink) {\n            res += FileType.SymbolicLink;\n        }\n        return res;\n    }\n    export function toStat(stat: FileStat): Stat | { type: FileType } & Partial<Stat> {\n        return {\n            type: asFileType(stat),\n            ctime: stat.ctime,\n            mtime: stat.mtime,\n            size: stat.size\n        };\n    }\n    export function fromStat(resource: URI, stat: Stat): FileStatWithMetadata;\n    export function fromStat(resource: URI, stat: { type: FileType } & Partial<Stat>): FileStat;\n    export function fromStat(resource: URI, stat: Stat | { type: FileType } & Partial<Stat>): FileStat {\n        return {\n            resource,\n            name: resource.path.base || resource.path.toString(),\n            isFile: (stat.type & FileType.File) !== 0,\n            isDirectory: (stat.type & FileType.Directory) !== 0,\n            isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            size: stat.size,\n            etag: etag({ mtime: stat.mtime, size: stat.size })\n        };\n    }\n    export function dir(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\n        return fromStat(resource instanceof URI ? resource : new URI(resource), { type: FileType.Directory, ...stat });\n    }\n    export function file(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\n        return fromStat(resource instanceof URI ? resource : new URI(resource), { type: FileType.File, ...stat });\n    }\n}\n\nexport interface FileStatWithMetadata extends FileStat, BaseStatWithMetadata {\n    mtime: number;\n    ctime: number;\n    etag: string;\n    size: number;\n    children?: FileStatWithMetadata[];\n}\n\nexport interface ResolveFileResult {\n    stat?: FileStat;\n    success: boolean;\n}\n\nexport interface ResolveFileResultWithMetadata extends ResolveFileResult {\n    stat?: FileStatWithMetadata;\n}\n\nexport interface FileContent extends BaseStatWithMetadata {\n\n    /**\n     * The content of a file as buffer.\n     */\n    value: BinaryBuffer;\n}\n\nexport interface FileStreamContent extends BaseStatWithMetadata {\n\n    /**\n     * The content of a file as stream.\n     */\n    value: BinaryBufferReadableStream;\n}\n\nexport interface WriteFileOptions {\n\n    /**\n     * The last known modification time of the file. This can be used to prevent dirty writes.\n     */\n    readonly mtime?: number;\n\n    /**\n     * The etag of the file. This can be used to prevent dirty writes.\n     */\n    readonly etag?: string;\n}\n\nexport interface ReadFileOptions extends FileReadStreamOptions {\n\n    /**\n     * The optional etag parameter allows to return early from resolving the resource if\n     * the contents on disk match the etag. This prevents accumulated reading of resources\n     * that have been read already with the same etag.\n     * It is the task of the caller to makes sure to handle this error case from the promise.\n     */\n    readonly etag?: string;\n}\n\nexport interface WriteFileOptions {\n\n    /**\n     * The last known modification time of the file. This can be used to prevent dirty writes.\n     */\n    readonly mtime?: number;\n\n    /**\n     * The etag of the file. This can be used to prevent dirty writes.\n     */\n    readonly etag?: string;\n}\n\nexport interface ResolveFileOptions {\n\n    /**\n     * Automatically continue resolving children of a directory until the provided resources\n     * are found.\n     */\n    readonly resolveTo?: readonly URI[];\n\n    /**\n     * Automatically continue resolving children of a directory if the number of children is 1.\n     */\n    readonly resolveSingleChildDescendants?: boolean;\n\n    /**\n     * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact\n     * on performance and thus should only be used when these values are required.\n     */\n    readonly resolveMetadata?: boolean;\n}\n\nexport interface ResolveMetadataFileOptions extends ResolveFileOptions {\n    readonly resolveMetadata: true;\n}\n\nexport interface FileOperationOptions {\n    /**\n     * Indicates that a user action triggered the opening, e.g.\n     * via mouse or keyboard use. Default is true.\n     */\n    fromUserGesture?: boolean\n}\n\nexport interface MoveFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport interface CopyFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport interface CreateFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport class FileOperationError extends Error {\n    constructor(message: string, public fileOperationResult: FileOperationResult, public options?: ReadFileOptions & WriteFileOptions & CreateFileOptions) {\n        super(message);\n        Object.setPrototypeOf(this, FileOperationError.prototype);\n    }\n}\n\nexport const enum FileOperationResult {\n    FILE_IS_DIRECTORY,\n    FILE_NOT_FOUND,\n    FILE_NOT_MODIFIED_SINCE,\n    FILE_MODIFIED_SINCE,\n    FILE_MOVE_CONFLICT,\n    FILE_READ_ONLY,\n    FILE_PERMISSION_DENIED,\n    FILE_TOO_LARGE,\n    FILE_INVALID_PATH,\n    FILE_EXCEEDS_MEMORY_LIMIT,\n    FILE_NOT_DIRECTORY,\n    FILE_OTHER_ERROR\n}\n\nexport interface FileOverwriteOptions {\n    /**\n     * Overwrite the file to create if it already exists on disk. Otherwise\n     * an error will be thrown (FILE_MODIFIED_SINCE).\n     */\n    overwrite: boolean;\n}\n\nexport interface FileReadStreamOptions {\n\n    /**\n     * Is an integer specifying where to begin reading from in the file. If position is undefined,\n     * data will be read from the current file position.\n     */\n    readonly position?: number;\n\n    /**\n     * Is an integer specifying how many bytes to read from the file. By default, all bytes\n     * will be read.\n     */\n    readonly length?: number;\n\n    /**\n     * If provided, the size of the file will be checked against the limits.\n     */\n    limits?: {\n        readonly size?: number;\n        readonly memory?: number;\n    };\n}\n\nexport interface FileUpdateOptions {\n    readEncoding: string;\n    writeEncoding: string;\n    overwriteEncoding: boolean;\n}\nexport interface FileUpdateResult extends Stat {\n    encoding: string;\n}\n\nexport interface FileWriteOptions {\n    overwrite: boolean;\n    create: boolean;\n}\n\nexport interface FileOpenOptions {\n    create: boolean;\n}\n\nexport interface FileDeleteOptions {\n    recursive: boolean;\n    useTrash: boolean;\n}\n\nexport enum FileType {\n    Unknown = 0,\n    File = 1,\n    Directory = 2,\n    SymbolicLink = 64\n}\n\nexport interface Stat {\n    type: FileType;\n\n    /**\n     * The last modification date represented as millis from unix epoch.\n     */\n    mtime: number;\n\n    /**\n     * The creation date represented as millis from unix epoch.\n     */\n    ctime: number;\n\n    size: number;\n}\n\nexport interface WatchOptions {\n    recursive: boolean;\n    excludes: string[];\n}\n\nexport const enum FileSystemProviderCapabilities {\n    FileReadWrite = 1 << 1,\n    FileOpenReadWriteClose = 1 << 2,\n    FileReadStream = 1 << 4,\n\n    FileFolderCopy = 1 << 3,\n\n    PathCaseSensitive = 1 << 10,\n    Readonly = 1 << 11,\n\n    Trash = 1 << 12,\n\n    Access = 1 << 24,\n    Update = 1 << 25\n}\n\nexport enum FileSystemProviderErrorCode {\n    FileExists = 'EntryExists',\n    FileNotFound = 'EntryNotFound',\n    FileNotADirectory = 'EntryNotADirectory',\n    FileIsADirectory = 'EntryIsADirectory',\n    FileExceedsMemoryLimit = 'EntryExceedsMemoryLimit',\n    FileTooLarge = 'EntryTooLarge',\n    NoPermissions = 'NoPermissions',\n    Unavailable = 'Unavailable',\n    Unknown = 'Unknown'\n}\n\nexport class FileSystemProviderError extends Error {\n\n    constructor(message: string, public readonly code: FileSystemProviderErrorCode) {\n        super(message);\n        Object.setPrototypeOf(this, FileSystemProviderError.prototype);\n    }\n}\n\nexport function createFileSystemProviderError(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n    const providerError = new FileSystemProviderError(error.toString(), code);\n    markAsFileSystemProviderError(providerError, code);\n\n    return providerError;\n}\n\nexport function ensureFileSystemProviderError(error?: Error): Error {\n    if (!error) {\n        return createFileSystemProviderError('Unknown Error', FileSystemProviderErrorCode.Unknown); // https://github.com/Microsoft/vscode/issues/72798\n    }\n\n    return error;\n}\n\nexport const FileSystemProvider = Symbol('FileSystemProvider');\n/**\n * A {@link FileSystemProvider} provides the capabilities to read, write, discover, and to manage files and folders\n * of the underlying (potentially virtual) file system. {@link FileSystemProvider}s can be used to serve files from both the\n * local disk as well as remote locations like ftp-servers, REST-services etc. A {@link FileSystemProvider} is registered for a certain\n * scheme and can handle all resources whose uri does conform to that scheme.\n */\nexport interface FileSystemProvider {\n\n    /** The {@link FileSystemProviderCapabilities} for this provider. */\n    readonly capabilities: FileSystemProviderCapabilities;\n\n    /** * Event that is fired if the capabilities of this provider have changed. */\n    readonly onDidChangeCapabilities: Event<void>;\n\n    /** Event that is fired if a (watched) file in the filesystem of this provider has changed. */\n    readonly onDidChangeFile: Event<readonly FileChange[]>;\n\n    /** Event that is fired if an error occurred when watching files in the filesystem of this provider. */\n    readonly onFileWatchError: Event<void>;\n\n    /**\n     * Watch the given resource and react to changes by firing the {@link FileSystemProvider#onDidChangeFile} event.\n     * @param resource `URI` of the resource to be watched.\n     * @param opts Options to define if the resource should be watched recursively and to\n     *  provide a set of resources that should be excluded from watching.\n     *\n     * @returns A `Disposable` that can be invoked to stop watching the resource.\n     */\n    watch(resource: URI, opts: WatchOptions): IDisposable;\n\n    /**\n     * Retrieve metadata about a given file.\n     *\n     * @param uri The `URI` of the file to retrieve meta data about.\n     * @returns A promise of the metadata about the resource.\n     */\n    stat(resource: URI): Promise<Stat>;\n\n    /**\n     * Create a new directory using the given resource uri.\n     * @param resource The `URI` of the new folder.\n     */\n    mkdir(resource: URI): Promise<void>;\n\n    /**\n     * Retrieve the content of a given directory.\n     * @param resource The `URI` of the directory.\n     *\n     * @returns A map containing the {@link FileType} for each child resource, identified by name.\n     */\n    readdir(resource: URI): Promise<[string, FileType][]>;\n\n    /**\n     * Delete the given resource.\n     * @param resource The `URI` of the resource to delete.\n     * @param opts Options to define if files should be deleted recursively and if the trash should be used.\n     */\n    delete(resource: URI, opts: FileDeleteOptions): Promise<void>;\n\n    /**\n     * Rename a file or folder.\n     * @param from `URI` of the existing file or folder.\n     * @param to `URI` of the target location.\n     * @param opts Options to define if existing files should be overwritten.\n     */\n    rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileFolderCopyCapability}.\n     * See {@link FileSystemProviderWithFileFolderCopyCapability#copy}} for additional documentation.\n     */\n    copy?(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\n     * See {@link FileSystemProviderWithFileReadWriteCapability#readFile} for additional documentation.\n     */\n    readFile?(resource: URI): Promise<Uint8Array>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\n     * See {@link FileSystemProviderWithFileReadWriteCapability#writeFile} for additional documentation.\n     */\n    writeFile?(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadStreamCapability}.\n     * See {@link FileSystemProviderWithFileReadStreamCapability#readFileStream} for additional documentation.\n     */\n    readFileStream?(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#open} for additional documentation.\n     */\n    open?(resource: URI, opts: FileOpenOptions): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#close} for additional documentation.\n     */\n    close?(fd: number): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#read} for additional documentation.\n     */\n    read?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#write} for additional documentation.\n     */\n    write?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\n     * See {@link FileSystemProviderWithAccessCapability#access} for additional documentation.\n     */\n    access?(resource: URI, mode?: number): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\n     * See {@link FileSystemProviderWithAccessCapability#fsPath} for additional documentation.\n     */\n    fsPath?(resource: URI): Promise<string>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithUpdateCapability}.\n     * See {@link FileSystemProviderWithUpdateCapability#updateFile} for additional documentation.\n     */\n    updateFile?(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed for providers, that should be\n * able access files, are implemented.\n */\nexport interface FileSystemProviderWithAccessCapability extends FileSystemProvider {\n    /**\n     * Test if the user has the permission to access the given file in the specified mode.\n     * @param resource The `URI` of the file that should be tested.\n     * @param mode The access mode that should be tested.\n     *\n     * @returns A promise that resolves if the user has the required permissions, should be rejected otherwise.\n     */\n    access(resource: URI, mode?: number): Promise<void>;\n\n    /**\n     * Derive the platform specific file system path that is represented by the resource.\n     * @param resource `URI` of the resource to derive the path from.\n     *\n     * @returns A promise of the corresponding file system path.\n     */\n    fsPath(resource: URI): Promise<string>;\n}\n\nexport function hasAccessCapability(provider: FileSystemProvider): provider is FileSystemProviderWithAccessCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Access);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed, for providers that should be\n * able to update (text) files, are implemented.\n */\nexport interface FileSystemProviderWithUpdateCapability extends FileSystemProvider {\n    /**\n     * Update the content of the given (text) file according to the given text document changes.\n     * @param resource `URI` of the resource to update.\n     * @param changes Array of events describing the changes to the file.\n     * @param opts The encoding options.\n     *\n     * @returns A promise of the file metadata that resolves after the update process has completed.\n     */\n    updateFile(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\n}\n\nexport function hasUpdateCapability(provider: FileSystemProvider): provider is FileSystemProviderWithUpdateCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Update);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers\n * that should be able to read & write files, are implemented.\n */\nexport interface FileSystemProviderWithFileReadWriteCapability extends FileSystemProvider {\n    /**\n     * Read the contents of the given file as stream.\n     * @param resource The `URI` of the file.\n     *\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\n     */\n    readFile(resource: URI): Promise<Uint8Array>;\n\n    /**\n     *  Write data to a file, replacing its entire contents.\n     * @param resource The uri of the file.\n     * @param content The new content of the file.\n     * @param opts Options to define if the file should be created if missing and if an existing file should be overwritten.\n     */\n    writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n}\n\nexport function hasReadWriteCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadWriteCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to copy\n * file folders, are implemented.\n */\nexport interface FileSystemProviderWithFileFolderCopyCapability extends FileSystemProvider {\n    /**\n     * Copy files or folders.\n     * @param from `URI` of the existing file or folder.\n     * @param to `URI` of the destination location.\n     * @param opts Options to define if existing files should be overwritten.\n     */\n    copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n}\n\nexport function hasFileFolderCopyCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileFolderCopyCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to open,read, write\n * or close files, are implemented.\n */\nexport interface FileSystemProviderWithOpenReadWriteCloseCapability extends FileSystemProvider {\n    /**\n     * Open the give file.\n     * @param resource The `URI` of the file to open.\n     * @param opts Options to define if the file should be created if it does not exist yet.\n     *\n     * @returns A promise of the file descriptor that resolves after the file is open.\n     */\n    open(resource: URI, opts: FileOpenOptions): Promise<number>;\n\n    /**\n     * Close the file with the given file descriptor.\n     * @param fd the file descriptor to close.\n     */\n    close(fd: number): Promise<void>;\n\n    /**\n     * Read specified content from a given file descriptor into a data buffer.\n     * @param fd The file descriptor referencing the file to read from.\n     * @param pos The offset from the beginning of the file from which data should be read.\n     * @param data The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     *\n     * @returns A promise of the number of bytes read.\n     */\n    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Write specified content from the data buffer to the file referenced by the given file descriptor.\n     * @param fd The file descriptor referencing the file to write to.\n     * @param pos The offset from the beginning of the file where this data should be written.\n     * @param offset The part of the buffer to be read from.\n     * @param length The number of bytes to write.\n     *\n     * @returns A promise of the number of bytes written.\n     */\n    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport function hasOpenReadWriteCloseCapability(provider: FileSystemProvider): provider is FileSystemProviderWithOpenReadWriteCloseCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to read\n * files as streams, are implemented.\n */\nexport interface FileSystemProviderWithFileReadStreamCapability extends FileSystemProvider {\n    /**\n     * Read the  contents of the given file as stream.\n     * @param resource The `URI` of the file.\n     *\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\n     */\n    readFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n}\n\nexport function hasFileReadStreamCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadStreamCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);\n}\n\nexport function markAsFileSystemProviderError(error: Error, code: FileSystemProviderErrorCode): Error {\n    error.name = code ? `${code} (FileSystemError)` : 'FileSystemError';\n\n    return error;\n}\n\nexport function toFileSystemProviderErrorCode(error: Error | undefined | null): FileSystemProviderErrorCode {\n\n    // Guard against abuse\n    if (!error) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n\n    // FileSystemProviderError comes with the code\n    if (error instanceof FileSystemProviderError) {\n        return error.code;\n    }\n\n    // Any other error, check for name match by assuming that the error\n    // went through the markAsFileSystemProviderError() method\n    const match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\n    if (!match) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n\n    switch (match[1]) {\n        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;\n        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;\n        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;\n        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit: return FileSystemProviderErrorCode.FileExceedsMemoryLimit;\n        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;\n        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;\n        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;\n    }\n\n    return FileSystemProviderErrorCode.Unknown;\n}\n\nexport function toFileOperationResult(error: Error): FileOperationResult {\n\n    // FileSystemProviderError comes with the result already\n    if (error instanceof FileOperationError) {\n        return error.fileOperationResult;\n    }\n\n    // Otherwise try to find from code\n    switch (toFileSystemProviderErrorCode(error)) {\n        case FileSystemProviderErrorCode.FileNotFound:\n            return FileOperationResult.FILE_NOT_FOUND;\n        case FileSystemProviderErrorCode.FileIsADirectory:\n            return FileOperationResult.FILE_IS_DIRECTORY;\n        case FileSystemProviderErrorCode.FileNotADirectory:\n            return FileOperationResult.FILE_NOT_DIRECTORY;\n        case FileSystemProviderErrorCode.NoPermissions:\n            return FileOperationResult.FILE_PERMISSION_DENIED;\n        case FileSystemProviderErrorCode.FileExists:\n            return FileOperationResult.FILE_MOVE_CONFLICT;\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit:\n            return FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n        case FileSystemProviderErrorCode.FileTooLarge:\n            return FileOperationResult.FILE_TOO_LARGE;\n        default:\n            return FileOperationResult.FILE_OTHER_ERROR;\n    }\n}\n\n/**\n * A hint to disable etag checking for reading/writing.\n */\nexport const ETAG_DISABLED = '';\n\nexport function etag(stat: { mtime: number, size: number }): string;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined {\n    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\n        return undefined;\n    }\n\n    return stat.mtime.toString(29) + stat.size.toString(31);\n}\n/**\n * Helper to format a raw byte size into a human readable label.\n */\nexport class BinarySize {\n    static readonly KB = 1024;\n    static readonly MB = BinarySize.KB * BinarySize.KB;\n    static readonly GB = BinarySize.MB * BinarySize.KB;\n    static readonly TB = BinarySize.GB * BinarySize.KB;\n\n    static formatSize(size: number): string {\n        if (size < BinarySize.KB) {\n            return size + 'B';\n        }\n        if (size < BinarySize.MB) {\n            return (size / BinarySize.KB).toFixed(2) + 'KB';\n        }\n        if (size < BinarySize.GB) {\n            return (size / BinarySize.MB).toFixed(2) + 'MB';\n        }\n        if (size < BinarySize.TB) {\n            return (size / BinarySize.GB).toFixed(2) + 'GB';\n        }\n        return (size / BinarySize.TB).toFixed(2) + 'TB';\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2018 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { FileStat } from '../common/files';\nimport URI from '@theia/core/lib/common/uri';\n\nexport namespace FileSystemUtils {\n\n    /**\n     * Generate unique URI for a given parent which does not collide\n     *\n     * @param parentUri the `URI` of the parent\n     * @param parent the `FileStat` of the parent\n     * @param name the resource name\n     * @param ext the resource extension\n     */\n    export function generateUniqueResourceURI(parentUri: URI, parent: FileStat, name: string, ext: string = ''): URI {\n        const children = !parent.children ? [] : parent.children!.map(child => child.resource);\n\n        let index = 1;\n        let base = name + ext;\n        while (children.some(child => child.path.base === base)) {\n            index = index + 1;\n            base = name + '_' + index + ext;\n        }\n        return parentUri.resolve(base);\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/io.ts\n\n/* eslint-disable max-len */\n\nimport URI from '@theia/core/lib/common/uri';\nimport { BinaryBuffer } from '@theia/core/lib/common//buffer';\nimport { CancellationToken, cancelled as canceled } from '@theia/core/lib/common/cancellation';\nimport { FileSystemProviderWithOpenReadWriteCloseCapability, FileReadStreamOptions, ensureFileSystemProviderError, createFileSystemProviderError, FileSystemProviderErrorCode } from './files';\nimport { WriteableStream, ErrorTransformer, DataTransformer } from '@theia/core/lib/common/stream';\n\nexport interface CreateReadStreamOptions extends FileReadStreamOptions {\n\n    /**\n     * The size of the buffer to use before sending to the stream.\n     */\n    bufferSize: number;\n\n    /**\n     * Allows to massage any possibly error that happens during reading.\n     */\n    errorTransformer?: ErrorTransformer;\n}\n\n/**\n * A helper to read a file from a provider with open/read/close capability into a stream.\n */\nexport async function readFileIntoStream<T>(\n    provider: FileSystemProviderWithOpenReadWriteCloseCapability,\n    resource: URI,\n    target: WriteableStream<T>,\n    transformer: DataTransformer<BinaryBuffer, T>,\n    options: CreateReadStreamOptions,\n    token: CancellationToken\n): Promise<void> {\n    let error: Error | undefined = undefined;\n\n    try {\n        await doReadFileIntoStream(provider, resource, target, transformer, options, token);\n    } catch (err) {\n        error = err;\n    } finally {\n        if (error && options.errorTransformer) {\n            error = options.errorTransformer(error);\n        }\n\n        target.end(error);\n    }\n}\n\nasync function doReadFileIntoStream<T>(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, target: WriteableStream<T>, transformer: DataTransformer<BinaryBuffer, T>, options: CreateReadStreamOptions, token: CancellationToken): Promise<void> {\n\n    // Check for cancellation\n    throwIfCancelled(token);\n\n    // open handle through provider\n    const handle = await provider.open(resource, { create: false });\n\n    // Check for cancellation\n    throwIfCancelled(token);\n\n    try {\n        let totalBytesRead = 0;\n        let bytesRead = 0;\n        let allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;\n\n        let buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n        let posInFile = options && typeof options.position === 'number' ? options.position : 0;\n        let posInBuffer = 0;\n        do {\n            // read from source (handle) at current position (pos) into buffer (buffer) at\n            // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n            bytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n            posInFile += bytesRead;\n            posInBuffer += bytesRead;\n            totalBytesRead += bytesRead;\n\n            if (typeof allowedRemainingBytes === 'number') {\n                allowedRemainingBytes -= bytesRead;\n            }\n\n            // when buffer full, create a new one and emit it through stream\n            if (posInBuffer === buffer.byteLength) {\n                await target.write(transformer(buffer));\n\n                buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n                posInBuffer = 0;\n            }\n        } while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));\n\n        // wrap up with last buffer (also respect maxBytes if provided)\n        if (posInBuffer > 0) {\n            let lastChunkLength = posInBuffer;\n            if (typeof allowedRemainingBytes === 'number') {\n                lastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\n            }\n\n            target.write(transformer(buffer.slice(0, lastChunkLength)));\n        }\n    } catch (error) {\n        throw ensureFileSystemProviderError(error);\n    } finally {\n        await provider.close(handle);\n    }\n}\n\nfunction throwIfCancelled(token: CancellationToken): boolean {\n    if (token.isCancellationRequested) {\n        throw canceled();\n    }\n\n    return true;\n}\n\nfunction throwIfTooLarge(totalBytesRead: number, options: CreateReadStreamOptions): boolean {\n\n    // Return early if file is too large to load and we have configured limits\n    if (options?.limits) {\n        if (typeof options.limits.memory === 'number' && totalBytesRead > options.limits.memory) {\n            throw createFileSystemProviderError('To open a file of this size, you need to restart and allow it to use more memory', FileSystemProviderErrorCode.FileExceedsMemoryLimit);\n        }\n\n        if (typeof options.limits.size === 'number' && totalBytesRead > options.limits.size) {\n            throw createFileSystemProviderError('File is too large to open', FileSystemProviderErrorCode.FileTooLarge);\n        }\n    }\n\n    return true;\n}\n"],"sourceRoot":""}