(self["webpackChunkbrowser_app"] = self["webpackChunkbrowser_app"] || []).push([["vendors-node_modules_theia_monaco_lib_browser_monaco-workspace_js"],{

/***/ "../node_modules/@theia/core/shared/vscode-languageserver-protocol.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/core/shared/vscode-languageserver-protocol.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! vscode-languageserver-protocol */ "../node_modules/vscode-languageserver-protocol/lib/main.js");

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/main.js":
/*!******************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.CancellationToken = vscode_jsonrpc_1.CancellationToken;
exports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
exports.Disposable = vscode_jsonrpc_1.Disposable;
exports.Event = vscode_jsonrpc_1.Event;
exports.Emitter = vscode_jsonrpc_1.Emitter;
exports.Trace = vscode_jsonrpc_1.Trace;
exports.TraceFormat = vscode_jsonrpc_1.TraceFormat;
exports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
exports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
exports.MessageReader = vscode_jsonrpc_1.MessageReader;
exports.MessageWriter = vscode_jsonrpc_1.MessageWriter;
exports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
exports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
exports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
exports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
exports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
exports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
exports.ProgressType = vscode_jsonrpc_1.ProgressType;

__export(__webpack_require__(/*! vscode-languageserver-types */ "../node_modules/vscode-languageserver-protocol/node_modules/vscode-languageserver-types/lib/esm/main.js"));

__export(__webpack_require__(/*! ./protocol */ "../node_modules/vscode-languageserver-protocol/lib/protocol.js"));

var callHierarchy = __webpack_require__(/*! ./protocol.callHierarchy.proposed */ "../node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js");

var st = __webpack_require__(/*! ./protocol.sematicTokens.proposed */ "../node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js");

var Proposed;

(function (Proposed) {
  var CallHierarchyPrepareRequest;

  (function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = callHierarchy.CallHierarchyPrepareRequest.method;
    CallHierarchyPrepareRequest.type = callHierarchy.CallHierarchyPrepareRequest.type;
  })(CallHierarchyPrepareRequest = Proposed.CallHierarchyPrepareRequest || (Proposed.CallHierarchyPrepareRequest = {}));

  var CallHierarchyIncomingCallsRequest;

  (function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
    CallHierarchyIncomingCallsRequest.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
  })(CallHierarchyIncomingCallsRequest = Proposed.CallHierarchyIncomingCallsRequest || (Proposed.CallHierarchyIncomingCallsRequest = {}));

  var CallHierarchyOutgoingCallsRequest;

  (function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
    CallHierarchyOutgoingCallsRequest.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
  })(CallHierarchyOutgoingCallsRequest = Proposed.CallHierarchyOutgoingCallsRequest || (Proposed.CallHierarchyOutgoingCallsRequest = {}));

  Proposed.SemanticTokenTypes = st.SemanticTokenTypes;
  Proposed.SemanticTokenModifiers = st.SemanticTokenModifiers;
  Proposed.SemanticTokens = st.SemanticTokens;
  var SemanticTokensRequest;

  (function (SemanticTokensRequest) {
    SemanticTokensRequest.method = st.SemanticTokensRequest.method;
    SemanticTokensRequest.type = st.SemanticTokensRequest.type;
  })(SemanticTokensRequest = Proposed.SemanticTokensRequest || (Proposed.SemanticTokensRequest = {}));

  var SemanticTokensEditsRequest;

  (function (SemanticTokensEditsRequest) {
    SemanticTokensEditsRequest.method = st.SemanticTokensEditsRequest.method;
    SemanticTokensEditsRequest.type = st.SemanticTokensEditsRequest.type;
  })(SemanticTokensEditsRequest = Proposed.SemanticTokensEditsRequest || (Proposed.SemanticTokensEditsRequest = {}));

  var SemanticTokensRangeRequest;

  (function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = st.SemanticTokensRangeRequest.method;
    SemanticTokensRangeRequest.type = st.SemanticTokensRangeRequest.type;
  })(SemanticTokensRangeRequest = Proposed.SemanticTokensRangeRequest || (Proposed.SemanticTokensRangeRequest = {}));
})(Proposed = exports.Proposed || (exports.Proposed = {}));

function createProtocolConnection(reader, writer, logger, strategy) {
  return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
}

exports.createProtocolConnection = createProtocolConnection;

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/messages.js":
/*!**********************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/messages.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "../node_modules/@babel/runtime/helpers/classCallCheck.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "../node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "../node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var ProtocolRequestType0 = /*#__PURE__*/function (_vscode_jsonrpc_1$Req) {
  _inherits(ProtocolRequestType0, _vscode_jsonrpc_1$Req);

  var _super = _createSuper(ProtocolRequestType0);

  function ProtocolRequestType0(method) {
    _classCallCheck(this, ProtocolRequestType0);

    return _super.call(this, method);
  }

  return ProtocolRequestType0;
}(vscode_jsonrpc_1.RequestType0);

exports.ProtocolRequestType0 = ProtocolRequestType0;

var ProtocolRequestType = /*#__PURE__*/function (_vscode_jsonrpc_1$Req2) {
  _inherits(ProtocolRequestType, _vscode_jsonrpc_1$Req2);

  var _super2 = _createSuper(ProtocolRequestType);

  function ProtocolRequestType(method) {
    _classCallCheck(this, ProtocolRequestType);

    return _super2.call(this, method);
  }

  return ProtocolRequestType;
}(vscode_jsonrpc_1.RequestType);

exports.ProtocolRequestType = ProtocolRequestType;

var ProtocolNotificationType = /*#__PURE__*/function (_vscode_jsonrpc_1$Not) {
  _inherits(ProtocolNotificationType, _vscode_jsonrpc_1$Not);

  var _super3 = _createSuper(ProtocolNotificationType);

  function ProtocolNotificationType(method) {
    _classCallCheck(this, ProtocolNotificationType);

    return _super3.call(this, method);
  }

  return ProtocolNotificationType;
}(vscode_jsonrpc_1.NotificationType);

exports.ProtocolNotificationType = ProtocolNotificationType;

var ProtocolNotificationType0 = /*#__PURE__*/function (_vscode_jsonrpc_1$Not2) {
  _inherits(ProtocolNotificationType0, _vscode_jsonrpc_1$Not2);

  var _super4 = _createSuper(ProtocolNotificationType0);

  function ProtocolNotificationType0(method) {
    _classCallCheck(this, ProtocolNotificationType0);

    return _super4.call(this, method);
  }

  return ProtocolNotificationType0;
}(vscode_jsonrpc_1.NotificationType0);

exports.ProtocolNotificationType0 = ProtocolNotificationType0;

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0 - Proposed state
 */


var CallHierarchyPrepareRequest;

(function (CallHierarchyPrepareRequest) {
  CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
  CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */


var CallHierarchyIncomingCallsRequest;

(function (CallHierarchyIncomingCallsRequest) {
  CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
  CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0 - Proposed state
 */


var CallHierarchyOutgoingCallsRequest;

(function (CallHierarchyOutgoingCallsRequest) {
  CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
  CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js":
/*!************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */


var DocumentColorRequest;

(function (DocumentColorRequest) {
  DocumentColorRequest.method = 'textDocument/documentColor';
  DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
  /** @deprecated Use DocumentColorRequest.type */

  DocumentColorRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */


var ColorPresentationRequest;

(function (ColorPresentationRequest) {
  ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js":
/*!************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */


var ConfigurationRequest;

(function (ConfigurationRequest) {
  ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js"); // @ts-ignore: to avoid inlining LocatioLink as dynamic import


var __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */


var DeclarationRequest;

(function (DeclarationRequest) {
  DeclarationRequest.method = 'textDocument/declaration';
  DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
  /** @deprecated Use DeclarationRequest.type */

  DeclarationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * Enum of known range kinds
 */


var FoldingRangeKind;

(function (FoldingRangeKind) {
  /**
   * Folding range for a comment
   */
  FoldingRangeKind["Comment"] = "comment";
  /**
   * Folding range for a imports or includes
   */

  FoldingRangeKind["Imports"] = "imports";
  /**
   * Folding range for a region (e.g. `#region`)
   */

  FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */


var FoldingRangeRequest;

(function (FoldingRangeRequest) {
  FoldingRangeRequest.method = 'textDocument/foldingRange';
  FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
  /** @deprecated Use FoldingRangeRequest.type */

  FoldingRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js"); // @ts-ignore: to avoid inlining LocatioLink as dynamic import


var __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */


var ImplementationRequest;

(function (ImplementationRequest) {
  ImplementationRequest.method = 'textDocument/implementation';
  ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
  /** @deprecated Use ImplementationRequest.type */

  ImplementationRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.js":
/*!**********************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var Is = __webpack_require__(/*! ./utils/is */ "../node_modules/vscode-languageserver-protocol/lib/utils/is.js");

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");

var protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ "../node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js");

exports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;

var protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ "../node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js");

exports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;

var protocol_workspaceFolders_1 = __webpack_require__(/*! ./protocol.workspaceFolders */ "../node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js");

exports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
exports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;

var protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ "../node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js");

exports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;

var protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ "../node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js");

exports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
exports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;

var protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ "../node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js");

exports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;

var protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ "../node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js");

exports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;

var protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ "../node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js");

exports.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;

var protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ "../node_modules/vscode-languageserver-protocol/lib/protocol.progress.js");

exports.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
exports.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
exports.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification; // @ts-ignore: to avoid inlining LocatioLink as dynamic import

var __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */


var DocumentFilter;

(function (DocumentFilter) {
  function is(value) {
    var candidate = value;
    return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
  }

  DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */


var DocumentSelector;

(function (DocumentSelector) {
  function is(value) {
    if (!Array.isArray(value)) {
      return false;
    }

    var _iterator = _createForOfIteratorHelper(value),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var elem = _step.value;

        if (!Is.string(elem) && !DocumentFilter.is(elem)) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  }

  DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */


var RegistrationRequest;

(function (RegistrationRequest) {
  RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */


var UnregistrationRequest;

(function (UnregistrationRequest) {
  UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));

var ResourceOperationKind;

(function (ResourceOperationKind) {
  /**
   * Supports creating new files and folders.
   */
  ResourceOperationKind.Create = 'create';
  /**
   * Supports renaming existing files and folders.
   */

  ResourceOperationKind.Rename = 'rename';
  /**
   * Supports deleting existing files and folders.
   */

  ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));

var FailureHandlingKind;

(function (FailureHandlingKind) {
  /**
   * Applying the workspace change is simply aborted if one of the changes provided
   * fails. All operations executed before the failing operation stay executed.
   */
  FailureHandlingKind.Abort = 'abort';
  /**
   * All operations are executed transactional. That means they either all
   * succeed or no changes at all are applied to the workspace.
   */

  FailureHandlingKind.Transactional = 'transactional';
  /**
   * If the workspace edit contains only textual file changes they are executed transactional.
   * If resource changes (create, rename or delete file) are part of the change the failure
   * handling startegy is abort.
   */

  FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
  /**
   * The client tries to undo the operations already executed. But there is no
   * guarantee that this is succeeding.
   */

  FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */


var StaticRegistrationOptions;

(function (StaticRegistrationOptions) {
  function hasId(value) {
    var candidate = value;
    return candidate && Is.string(candidate.id) && candidate.id.length > 0;
  }

  StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */


var TextDocumentRegistrationOptions;

(function (TextDocumentRegistrationOptions) {
  function is(value) {
    var candidate = value;
    return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
  }

  TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */


var WorkDoneProgressOptions;

(function (WorkDoneProgressOptions) {
  function is(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is["boolean"](candidate.workDoneProgress));
  }

  WorkDoneProgressOptions.is = is;

  function hasWorkDoneProgress(value) {
    var candidate = value;
    return candidate && Is["boolean"](candidate.workDoneProgress);
  }

  WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */


var InitializeRequest;

(function (InitializeRequest) {
  InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */


var InitializeError;

(function (InitializeError) {
  /**
   * If the protocol version provided by the client can't be handled by the server.
   * @deprecated This initialize error got replaced by client capabilities. There is
   * no version handshake in version 3.0x
   */
  InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The intialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */


var InitializedNotification;

(function (InitializedNotification) {
  InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {})); //---- Shutdown Method ----

/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */


var ShutdownRequest;

(function (ShutdownRequest) {
  ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {})); //---- Exit Notification ----

/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */


var ExitNotification;

(function (ExitNotification) {
  ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */


var DidChangeConfigurationNotification;

(function (DidChangeConfigurationNotification) {
  DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {})); //---- Message show and log notifications ----

/**
 * The message type
 */


var MessageType;

(function (MessageType) {
  /**
   * An error message.
   */
  MessageType.Error = 1;
  /**
   * A warning message.
   */

  MessageType.Warning = 2;
  /**
   * An information message.
   */

  MessageType.Info = 3;
  /**
   * A log message.
   */

  MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */


var ShowMessageNotification;

(function (ShowMessageNotification) {
  ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */


var ShowMessageRequest;

(function (ShowMessageRequest) {
  ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */


var LogMessageNotification;

(function (LogMessageNotification) {
  LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {})); //---- Telemetry notification

/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */


var TelemetryEventNotification;

(function (TelemetryEventNotification) {
  TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */


var TextDocumentSyncKind;

(function (TextDocumentSyncKind) {
  /**
   * Documents should not be synced at all.
   */
  TextDocumentSyncKind.None = 0;
  /**
   * Documents are synced by always sending the full content
   * of the document.
   */

  TextDocumentSyncKind.Full = 1;
  /**
   * Documents are synced by sending the full content on open.
   * After that only incremental updates to the document are
   * send.
   */

  TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */


var DidOpenTextDocumentNotification;

(function (DidOpenTextDocumentNotification) {
  DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
  DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */


var DidChangeTextDocumentNotification;

(function (DidChangeTextDocumentNotification) {
  DidChangeTextDocumentNotification.method = 'textDocument/didChange';
  DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */


var DidCloseTextDocumentNotification;

(function (DidCloseTextDocumentNotification) {
  DidCloseTextDocumentNotification.method = 'textDocument/didClose';
  DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */


var DidSaveTextDocumentNotification;

(function (DidSaveTextDocumentNotification) {
  DidSaveTextDocumentNotification.method = 'textDocument/didSave';
  DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */


var TextDocumentSaveReason;

(function (TextDocumentSaveReason) {
  /**
   * Manually triggered, e.g. by the user pressing save, by starting debugging,
   * or by an API call.
   */
  TextDocumentSaveReason.Manual = 1;
  /**
   * Automatic after a delay.
   */

  TextDocumentSaveReason.AfterDelay = 2;
  /**
   * When the editor lost focus.
   */

  TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */


var WillSaveTextDocumentNotification;

(function (WillSaveTextDocumentNotification) {
  WillSaveTextDocumentNotification.method = 'textDocument/willSave';
  WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */


var WillSaveTextDocumentWaitUntilRequest;

(function (WillSaveTextDocumentWaitUntilRequest) {
  WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
  WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */


var DidChangeWatchedFilesNotification;

(function (DidChangeWatchedFilesNotification) {
  DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */


var FileChangeType;

(function (FileChangeType) {
  /**
   * The file got created.
   */
  FileChangeType.Created = 1;
  /**
   * The file got changed.
   */

  FileChangeType.Changed = 2;
  /**
   * The file got deleted.
   */

  FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));

var WatchKind;

(function (WatchKind) {
  /**
   * Interested in create events.
   */
  WatchKind.Create = 1;
  /**
   * Interested in change events
   */

  WatchKind.Change = 2;
  /**
   * Interested in delete events
   */

  WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */


var PublishDiagnosticsNotification;

(function (PublishDiagnosticsNotification) {
  PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */


var CompletionTriggerKind;

(function (CompletionTriggerKind) {
  /**
   * Completion was triggered by typing an identifier (24x7 code
   * complete), manual invocation (e.g Ctrl+Space) or via API.
   */
  CompletionTriggerKind.Invoked = 1;
  /**
   * Completion was triggered by a trigger character specified by
   * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
   */

  CompletionTriggerKind.TriggerCharacter = 2;
  /**
   * Completion was re-triggered as current completion list is incomplete
   */

  CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */


var CompletionRequest;

(function (CompletionRequest) {
  CompletionRequest.method = 'textDocument/completion';
  CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
  /** @deprecated Use CompletionRequest.type */

  CompletionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */


var CompletionResolveRequest;

(function (CompletionResolveRequest) {
  CompletionResolveRequest.method = 'completionItem/resolve';
  CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */


var HoverRequest;

(function (HoverRequest) {
  HoverRequest.method = 'textDocument/hover';
  HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */


var SignatureHelpTriggerKind;

(function (SignatureHelpTriggerKind) {
  /**
   * Signature help was invoked manually by the user or by a command.
   */
  SignatureHelpTriggerKind.Invoked = 1;
  /**
   * Signature help was triggered by a trigger character.
   */

  SignatureHelpTriggerKind.TriggerCharacter = 2;
  /**
   * Signature help was triggered by the cursor moving or by the document content changing.
   */

  SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));

var SignatureHelpRequest;

(function (SignatureHelpRequest) {
  SignatureHelpRequest.method = 'textDocument/signatureHelp';
  SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */


var DefinitionRequest;

(function (DefinitionRequest) {
  DefinitionRequest.method = 'textDocument/definition';
  DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
  /** @deprecated Use DefinitionRequest.type */

  DefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */


var ReferencesRequest;

(function (ReferencesRequest) {
  ReferencesRequest.method = 'textDocument/references';
  ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
  /** @deprecated Use ReferencesRequest.type */

  ReferencesRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */


var DocumentHighlightRequest;

(function (DocumentHighlightRequest) {
  DocumentHighlightRequest.method = 'textDocument/documentHighlight';
  DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
  /** @deprecated Use DocumentHighlightRequest.type */

  DocumentHighlightRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */


var DocumentSymbolRequest;

(function (DocumentSymbolRequest) {
  DocumentSymbolRequest.method = 'textDocument/documentSymbol';
  DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
  /** @deprecated Use DocumentSymbolRequest.type */

  DocumentSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */


var CodeActionRequest;

(function (CodeActionRequest) {
  CodeActionRequest.method = 'textDocument/codeAction';
  CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
  /** @deprecated Use CodeActionRequest.type */

  CodeActionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */


var WorkspaceSymbolRequest;

(function (WorkspaceSymbolRequest) {
  WorkspaceSymbolRequest.method = 'workspace/symbol';
  WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
  /** @deprecated Use WorkspaceSymbolRequest.type */

  WorkspaceSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */


var CodeLensRequest;

(function (CodeLensRequest) {
  CodeLensRequest.type = new messages_1.ProtocolRequestType('textDocument/codeLens');
  /** @deprecated Use CodeLensRequest.type */

  CodeLensRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */


var CodeLensResolveRequest;

(function (CodeLensResolveRequest) {
  CodeLensResolveRequest.type = new messages_1.ProtocolRequestType('codeLens/resolve');
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to provide document links
 */


var DocumentLinkRequest;

(function (DocumentLinkRequest) {
  DocumentLinkRequest.method = 'textDocument/documentLink';
  DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
  /** @deprecated Use DocumentLinkRequest.type */

  DocumentLinkRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */


var DocumentLinkResolveRequest;

(function (DocumentLinkResolveRequest) {
  DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType('documentLink/resolve');
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */


var DocumentFormattingRequest;

(function (DocumentFormattingRequest) {
  DocumentFormattingRequest.method = 'textDocument/formatting';
  DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */


var DocumentRangeFormattingRequest;

(function (DocumentRangeFormattingRequest) {
  DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
  DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */


var DocumentOnTypeFormattingRequest;

(function (DocumentOnTypeFormattingRequest) {
  DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
  DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
/**
 * A request to rename a symbol.
 */


var RenameRequest;

(function (RenameRequest) {
  RenameRequest.method = 'textDocument/rename';
  RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 */


var PrepareRenameRequest;

(function (PrepareRenameRequest) {
  PrepareRenameRequest.method = 'textDocument/prepareRename';
  PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */


var ExecuteCommandRequest;

(function (ExecuteCommandRequest) {
  ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */


var ApplyWorkspaceEditRequest;

(function (ApplyWorkspaceEditRequest) {
  ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.progress.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.progress.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");

var WorkDoneProgress;

(function (WorkDoneProgress) {
  WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */


var WorkDoneProgressCreateRequest;

(function (WorkDoneProgressCreateRequest) {
  WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */


var WorkDoneProgressCancelNotification;

(function (WorkDoneProgressCancelNotification) {
  WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */


var SelectionRangeRequest;

(function (SelectionRangeRequest) {
  SelectionRangeRequest.method = 'textDocument/selectionRange';
  SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
  /** @deprecated  Use SelectionRangeRequest.type */

  SelectionRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */


var SemanticTokenTypes;

(function (SemanticTokenTypes) {
  SemanticTokenTypes["comment"] = "comment";
  SemanticTokenTypes["keyword"] = "keyword";
  SemanticTokenTypes["string"] = "string";
  SemanticTokenTypes["number"] = "number";
  SemanticTokenTypes["regexp"] = "regexp";
  SemanticTokenTypes["operator"] = "operator";
  SemanticTokenTypes["namespace"] = "namespace";
  SemanticTokenTypes["type"] = "type";
  SemanticTokenTypes["struct"] = "struct";
  SemanticTokenTypes["class"] = "class";
  SemanticTokenTypes["interface"] = "interface";
  SemanticTokenTypes["enum"] = "enum";
  SemanticTokenTypes["typeParameter"] = "typeParameter";
  SemanticTokenTypes["function"] = "function";
  SemanticTokenTypes["member"] = "member";
  SemanticTokenTypes["property"] = "property";
  SemanticTokenTypes["macro"] = "macro";
  SemanticTokenTypes["variable"] = "variable";
  SemanticTokenTypes["parameter"] = "parameter";
  SemanticTokenTypes["label"] = "label";
})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0 - Proposed state
 */


var SemanticTokenModifiers;

(function (SemanticTokenModifiers) {
  SemanticTokenModifiers["documentation"] = "documentation";
  SemanticTokenModifiers["declaration"] = "declaration";
  SemanticTokenModifiers["definition"] = "definition";
  SemanticTokenModifiers["reference"] = "reference";
  SemanticTokenModifiers["static"] = "static";
  SemanticTokenModifiers["abstract"] = "abstract";
  SemanticTokenModifiers["deprecated"] = "deprecated";
  SemanticTokenModifiers["async"] = "async";
  SemanticTokenModifiers["volatile"] = "volatile";
  SemanticTokenModifiers["readonly"] = "readonly";
})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
/**
 * @since 3.16.0 - Proposed state
 */


var SemanticTokens;

(function (SemanticTokens) {
  function is(value) {
    var candidate = value;
    return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
  }

  SemanticTokens.is = is;
})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
/**
 * @since 3.16.0 - Proposed state
 */


var SemanticTokensRequest;

(function (SemanticTokensRequest) {
  SemanticTokensRequest.method = 'textDocument/semanticTokens';
  SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */


var SemanticTokensEditsRequest;

(function (SemanticTokensEditsRequest) {
  SemanticTokensEditsRequest.method = 'textDocument/semanticTokens/edits';
  SemanticTokensEditsRequest.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest.method);
})(SemanticTokensEditsRequest = exports.SemanticTokensEditsRequest || (exports.SemanticTokensEditsRequest = {}));
/**
 * @since 3.16.0 - Proposed state
 */


var SemanticTokensRangeRequest;

(function (SemanticTokensRangeRequest) {
  SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
  SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../node_modules/vscode-jsonrpc/lib/main.js");

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js"); // @ts-ignore: to avoid inlining LocatioLink as dynamic import


var __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */


var TypeDefinitionRequest;

(function (TypeDefinitionRequest) {
  TypeDefinitionRequest.method = 'textDocument/typeDefinition';
  TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
  /** @deprecated Use TypeDefinitionRequest.type */

  TypeDefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var messages_1 = __webpack_require__(/*! ./messages */ "../node_modules/vscode-languageserver-protocol/lib/messages.js");
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */


var WorkspaceFoldersRequest;

(function (WorkspaceFoldersRequest) {
  WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */


var DidChangeWorkspaceFoldersNotification;

(function (DidChangeWorkspaceFoldersNotification) {
  DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));

/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/lib/utils/is.js":
/*!**********************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/lib/utils/is.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */


var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../node_modules/@babel/runtime/helpers/typeof.js");

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

function _boolean(value) {
  return value === true || value === false;
}

exports.boolean = _boolean;

function string(value) {
  return typeof value === 'string' || value instanceof String;
}

exports.string = string;

function number(value) {
  return typeof value === 'number' || value instanceof Number;
}

exports.number = number;

function error(value) {
  return value instanceof Error;
}

exports.error = error;

function func(value) {
  return typeof value === 'function';
}

exports.func = func;

function array(value) {
  return Array.isArray(value);
}

exports.array = array;

function stringArray(value) {
  return array(value) && value.every(function (elem) {
    return string(elem);
  });
}

exports.stringArray = stringArray;

function typedArray(value, check) {
  return Array.isArray(value) && value.every(check);
}

exports.typedArray = typedArray;

function objectLiteral(value) {
  // Strictly speaking class instances pass this check as well. Since the LSP
  // doesn't use classes we ignore this for now. If we do we need to add something
  // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
  return value !== null && _typeof(value) === 'object';
}

exports.objectLiteral = objectLiteral;

/***/ }),

/***/ "../node_modules/@theia/core/shared/@phosphor/domutils.js":
/*!****************************************************************!*\
  !*** ../node_modules/@theia/core/shared/@phosphor/domutils.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! @phosphor/domutils */ "../node_modules/@phosphor/domutils/lib/index.js");


/***/ }),

/***/ "../node_modules/@theia/markers/lib/browser/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/@theia/markers/lib/browser/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (C) 2017 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./marker-manager */ "../node_modules/@theia/markers/lib/browser/marker-manager.js"), exports);
__exportStar(__webpack_require__(/*! ./problem/problem-manager */ "../node_modules/@theia/markers/lib/browser/problem/problem-manager.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/monaco-editor-model.js":
/*!************************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/monaco-editor-model.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/********************************************************************************
 * Copyright (C) 2017 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoEditorModel = exports.TextDocumentSaveReason = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol.js");
Object.defineProperty(exports, "TextDocumentSaveReason", ({ enumerable: true, get: function () { return vscode_languageserver_protocol_1.TextDocumentSaveReason; } }));
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../node_modules/@theia/core/lib/common/cancellation.js");
const resource_1 = __webpack_require__(/*! @theia/core/lib/common/resource */ "../node_modules/@theia/core/lib/common/resource.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-types */ "../node_modules/@theia/core/shared/vscode-languageserver-types.js");
class MonacoEditorModel {
    constructor(resource, m2p, p2m, logger, editorPreferences) {
        this.resource = resource;
        this.m2p = m2p;
        this.p2m = p2m;
        this.logger = logger;
        this.editorPreferences = editorPreferences;
        this.autoSave = 'on';
        this.autoSaveDelay = 500;
        this.suppressOpenEditorWhenDirty = false;
        this.lineNumbersMinChars = 3;
        /* @deprecated there is no general save timeout, each participant should introduce a sensible timeout  */
        this.onWillSaveLoopTimeOut = 1500;
        this.toDispose = new disposable_1.DisposableCollection();
        this.toDisposeOnAutoSave = new disposable_1.DisposableCollection();
        this.onDidChangeContentEmitter = new event_1.Emitter();
        this.onDidChangeContent = this.onDidChangeContentEmitter.event;
        this.onDidSaveModelEmitter = new event_1.Emitter();
        this.onDidSaveModel = this.onDidSaveModelEmitter.event;
        this.onWillSaveModelEmitter = new event_1.Emitter();
        this.onWillSaveModel = this.onWillSaveModelEmitter.event;
        this.onDidChangeValidEmitter = new event_1.Emitter();
        this.onDidChangeValid = this.onDidChangeValidEmitter.event;
        this.onDidChangeEncodingEmitter = new event_1.Emitter();
        this.onDidChangeEncoding = this.onDidChangeEncodingEmitter.event;
        /**
         * Use `valid` to access it.
         * Use `setValid` to mutate it.
         */
        this._valid = false;
        this._dirty = false;
        this.onDirtyChangedEmitter = new event_1.Emitter();
        this.pendingOperation = Promise.resolve();
        this.syncCancellationTokenSource = new cancellation_1.CancellationTokenSource();
        this.ignoreDirtyEdits = false;
        this.saveCancellationTokenSource = new cancellation_1.CancellationTokenSource();
        this.ignoreContentChanges = false;
        this.contentChanges = [];
        this.toDispose.push(resource);
        this.toDispose.push(this.toDisposeOnAutoSave);
        this.toDispose.push(this.onDidChangeContentEmitter);
        this.toDispose.push(this.onDidSaveModelEmitter);
        this.toDispose.push(this.onWillSaveModelEmitter);
        this.toDispose.push(this.onDirtyChangedEmitter);
        this.toDispose.push(this.onDidChangeValidEmitter);
        this.toDispose.push(disposable_1.Disposable.create(() => this.cancelSave()));
        this.toDispose.push(disposable_1.Disposable.create(() => this.cancelSync()));
        this.resolveModel = this.readContents().then(content => this.initialize(content || ''));
    }
    dispose() {
        this.toDispose.dispose();
    }
    setEncoding(encoding, mode) {
        if (mode === 1 /* Decode */ && this.dirty) {
            return Promise.resolve();
        }
        if (!this.setPreferredEncoding(encoding)) {
            return Promise.resolve();
        }
        if (mode === 1 /* Decode */) {
            return this.sync();
        }
        return this.scheduleSave(vscode_languageserver_protocol_1.TextDocumentSaveReason.Manual, this.cancelSave(), true);
    }
    getEncoding() {
        return this.preferredEncoding || this.contentEncoding;
    }
    setPreferredEncoding(encoding) {
        if (encoding === this.preferredEncoding || (!this.preferredEncoding && encoding === this.contentEncoding)) {
            return false;
        }
        this.preferredEncoding = encoding;
        this.onDidChangeEncodingEmitter.fire(encoding);
        return true;
    }
    updateContentEncoding() {
        const contentEncoding = this.resource.encoding;
        if (!contentEncoding || this.contentEncoding === contentEncoding) {
            return;
        }
        this.contentEncoding = contentEncoding;
        if (!this.preferredEncoding) {
            this.onDidChangeEncodingEmitter.fire(contentEncoding);
        }
    }
    /**
     * #### Important
     * Only this method can create an instance of `monaco.editor.IModel`,
     * there should not be other calls to `monaco.editor.createModel`.
     */
    initialize(value) {
        if (!this.toDispose.disposed) {
            const uri = monaco.Uri.parse(this.resource.uri.toString());
            let firstLine;
            if (typeof value === 'string') {
                firstLine = value;
                const firstLF = value.indexOf('\n');
                if (firstLF !== -1) {
                    firstLine = value.substring(0, firstLF);
                }
            }
            else {
                firstLine = value.getFirstLineText(1000);
            }
            const languageSelection = monaco.services.StaticServices.modeService.get().createByFilepathOrFirstLine(uri, firstLine);
            this.model = monaco.services.StaticServices.modelService.get().createModel(value, languageSelection, uri);
            this.resourceVersion = this.resource.version;
            this.updateSavedVersionId();
            this.toDispose.push(this.model);
            this.toDispose.push(this.model.onDidChangeContent(event => this.fireDidChangeContent(event)));
            if (this.resource.onDidChangeContents) {
                this.toDispose.push(this.resource.onDidChangeContents(() => this.sync()));
            }
        }
    }
    /**
     * Whether it is possible to load content from the underlying resource.
     */
    get valid() {
        return this._valid;
    }
    setValid(valid) {
        if (valid === this._valid) {
            return;
        }
        this._valid = valid;
        this.onDidChangeValidEmitter.fire(undefined);
    }
    get dirty() {
        return this._dirty;
    }
    setDirty(dirty) {
        if (dirty === this._dirty) {
            return;
        }
        this._dirty = dirty;
        if (dirty === false) {
            this.updateSavedVersionId();
        }
        this.onDirtyChangedEmitter.fire(undefined);
    }
    updateSavedVersionId() {
        this.bufferSavedVersionId = this.model.getAlternativeVersionId();
    }
    get onDirtyChanged() {
        return this.onDirtyChangedEmitter.event;
    }
    get uri() {
        return this.resource.uri.toString();
    }
    get languageId() {
        return this._languageId !== undefined ? this._languageId : this.model.getModeId();
    }
    /**
     * It's a hack to dispatch close notification with an old language id, don't use it.
     */
    setLanguageId(languageId) {
        this._languageId = languageId;
    }
    get version() {
        return this.model.getVersionId();
    }
    /**
     * Return selected text by Range or all text by default
     */
    getText(range) {
        if (!range) {
            return this.model.getValue();
        }
        else {
            return this.model.getValueInRange(this.p2m.asRange(range));
        }
    }
    positionAt(offset) {
        const { lineNumber, column } = this.model.getPositionAt(offset);
        return this.m2p.asPosition(lineNumber, column);
    }
    offsetAt(position) {
        return this.model.getOffsetAt(this.p2m.asPosition(position));
    }
    get lineCount() {
        return this.model.getLineCount();
    }
    /**
     * Retrieves a line in a text document expressed as a one-based position.
     */
    getLineContent(lineNumber) {
        return this.model.getLineContent(lineNumber);
    }
    getLineMaxColumn(lineNumber) {
        return this.model.getLineMaxColumn(lineNumber);
    }
    get readOnly() {
        return this.resource.saveContents === undefined;
    }
    get onDispose() {
        return this.toDispose.onDispose;
    }
    get textEditorModel() {
        return this.model;
    }
    /**
     * Find all matches in an editor for the given options.
     * @param options the options for finding matches.
     *
     * @returns the list of matches.
     */
    findMatches(options) {
        const wordSeparators = this.editorPreferences ? this.editorPreferences['editor.wordSeparators'] : browser_1.DEFAULT_WORD_SEPARATORS;
        const results = this.model.findMatches(options.searchString, false, options.isRegex, options.matchCase, 
        // eslint-disable-next-line no-null/no-null
        options.matchWholeWord ? wordSeparators : null, true, options.limitResultCount);
        const extractedMatches = [];
        results.forEach(r => {
            if (r.matches) {
                extractedMatches.push({
                    matches: r.matches,
                    range: vscode_languageserver_types_1.Range.create(r.range.startLineNumber, r.range.startColumn, r.range.endLineNumber, r.range.endColumn)
                });
            }
        });
        return extractedMatches;
    }
    async load() {
        await this.resolveModel;
        return this;
    }
    save(options) {
        return this.scheduleSave(vscode_languageserver_protocol_1.TextDocumentSaveReason.Manual, undefined, undefined, options);
    }
    async run(operation) {
        if (this.toDispose.disposed) {
            return;
        }
        return this.pendingOperation = this.pendingOperation.then(async () => {
            try {
                await operation();
            }
            catch (e) {
                console.error(e);
            }
        });
    }
    cancelSync() {
        this.trace(log => log('MonacoEditorModel.cancelSync'));
        this.syncCancellationTokenSource.cancel();
        this.syncCancellationTokenSource = new cancellation_1.CancellationTokenSource();
        return this.syncCancellationTokenSource.token;
    }
    async sync() {
        const token = this.cancelSync();
        return this.run(() => this.doSync(token));
    }
    async doSync(token) {
        this.trace(log => log('MonacoEditorModel.doSync - enter'));
        if (token.isCancellationRequested) {
            this.trace(log => log('MonacoEditorModel.doSync - exit - cancelled'));
            return;
        }
        const value = await this.readContents();
        if (value === undefined) {
            this.trace(log => log('MonacoEditorModel.doSync - exit - resource not found'));
            return;
        }
        if (token.isCancellationRequested) {
            this.trace(log => log('MonacoEditorModel.doSync - exit - cancelled while looking for a resource'));
            return;
        }
        if (this._dirty) {
            this.trace(log => log('MonacoEditorModel.doSync - exit - pending dirty changes'));
            return;
        }
        this.resourceVersion = this.resource.version;
        this.updateModel(() => monaco.services.StaticServices.modelService.get().updateModel(this.model, value), {
            ignoreDirty: true,
            ignoreContentChanges: true
        });
        this.trace(log => log('MonacoEditorModel.doSync - exit'));
    }
    async readContents() {
        try {
            const options = { encoding: this.getEncoding() };
            const content = await (this.resource.readStream ? this.resource.readStream(options) : this.resource.readContents(options));
            let value;
            if (typeof content === 'string') {
                value = content;
            }
            else {
                value = monaco.textModel.createTextBufferFactoryFromStream(content);
            }
            this.updateContentEncoding();
            this.setValid(true);
            return value;
        }
        catch (e) {
            this.setValid(false);
            if (resource_1.ResourceError.NotFound.is(e)) {
                return undefined;
            }
            throw e;
        }
    }
    markAsDirty() {
        this.trace(log => log('MonacoEditorModel.markAsDirty - enter'));
        if (this.ignoreDirtyEdits) {
            this.trace(log => log('MonacoEditorModel.markAsDirty - exit - ignoring dirty changes enabled'));
            return;
        }
        this.cancelSync();
        this.setDirty(true);
        this.doAutoSave();
        this.trace(log => log('MonacoEditorModel.markAsDirty - exit'));
    }
    doAutoSave() {
        if (this.autoSave === 'on') {
            const token = this.cancelSave();
            this.toDisposeOnAutoSave.dispose();
            const handle = window.setTimeout(() => {
                this.scheduleSave(vscode_languageserver_protocol_1.TextDocumentSaveReason.AfterDelay, token);
            }, this.autoSaveDelay);
            this.toDisposeOnAutoSave.push(disposable_1.Disposable.create(() => window.clearTimeout(handle)));
        }
    }
    cancelSave() {
        this.trace(log => log('MonacoEditorModel.cancelSave'));
        this.saveCancellationTokenSource.cancel();
        this.saveCancellationTokenSource = new cancellation_1.CancellationTokenSource();
        return this.saveCancellationTokenSource.token;
    }
    scheduleSave(reason, token = this.cancelSave(), overwriteEncoding, options) {
        return this.run(() => this.doSave(reason, token, overwriteEncoding, options));
    }
    pushContentChanges(contentChanges) {
        if (!this.ignoreContentChanges) {
            this.contentChanges.push(...contentChanges);
        }
    }
    fireDidChangeContent(event) {
        this.trace(log => log(`MonacoEditorModel.fireDidChangeContent - enter - ${JSON.stringify(event, undefined, 2)}`));
        if (this.model.getAlternativeVersionId() === this.bufferSavedVersionId) {
            this.setDirty(false);
        }
        else {
            this.markAsDirty();
        }
        const changeContentEvent = this.asContentChangedEvent(event);
        this.onDidChangeContentEmitter.fire(changeContentEvent);
        this.pushContentChanges(changeContentEvent.contentChanges);
        this.trace(log => log('MonacoEditorModel.fireDidChangeContent - exit'));
    }
    asContentChangedEvent(event) {
        const contentChanges = event.changes.map(change => this.asTextDocumentContentChangeEvent(change));
        return { model: this, contentChanges };
    }
    asTextDocumentContentChangeEvent(change) {
        const range = this.m2p.asRange(change.range);
        const rangeLength = change.rangeLength;
        const text = change.text;
        return { range, rangeLength, text };
    }
    applyEdits(operations, options) {
        return this.updateModel(() => this.model.applyEdits(operations), options);
    }
    updateModel(doUpdate, options) {
        const resolvedOptions = Object.assign({ ignoreDirty: false, ignoreContentChanges: false }, options);
        const { ignoreDirtyEdits, ignoreContentChanges } = this;
        this.ignoreDirtyEdits = resolvedOptions.ignoreDirty;
        this.ignoreContentChanges = resolvedOptions.ignoreContentChanges;
        try {
            return doUpdate();
        }
        finally {
            this.ignoreDirtyEdits = ignoreDirtyEdits;
            this.ignoreContentChanges = ignoreContentChanges;
        }
    }
    async doSave(reason, token, overwriteEncoding, options) {
        if (token.isCancellationRequested || !this.resource.saveContents) {
            return;
        }
        await this.fireWillSaveModel(reason, token, options);
        if (token.isCancellationRequested) {
            return;
        }
        const changes = [...this.contentChanges];
        if (changes.length === 0 && !overwriteEncoding && reason !== vscode_languageserver_protocol_1.TextDocumentSaveReason.Manual) {
            return;
        }
        const contentLength = this.model.getValueLength();
        const content = this.model.createSnapshot() || this.model.getValue();
        try {
            const encoding = this.getEncoding();
            const version = this.resourceVersion;
            await resource_1.Resource.save(this.resource, { changes, content, contentLength, options: { encoding, overwriteEncoding, version } }, token);
            this.contentChanges.splice(0, changes.length);
            this.resourceVersion = this.resource.version;
            this.updateContentEncoding();
            this.setValid(true);
            if (token.isCancellationRequested) {
                return;
            }
            this.setDirty(false);
            this.fireDidSaveModel();
        }
        catch (e) {
            if (!resource_1.ResourceError.OutOfSync.is(e)) {
                throw e;
            }
        }
    }
    async fireWillSaveModel(reason, token, options) {
        const firing = this.onWillSaveModelEmitter.sequence(async (listener) => {
            if (token.isCancellationRequested) {
                return false;
            }
            const waitables = [];
            const { version } = this;
            const event = {
                model: this, reason, options,
                waitUntil: (thenable) => {
                    if (Object.isFrozen(waitables)) {
                        throw new Error('waitUntil cannot be called asynchronously.');
                    }
                    waitables.push(thenable);
                }
            };
            // Fire.
            try {
                listener(event);
            }
            catch (err) {
                console.error(err);
                return true;
            }
            // Asynchronous calls to `waitUntil` should fail.
            Object.freeze(waitables);
            // Wait for all promises.
            const edits = await Promise.all(waitables).then(allOperations => [].concat(...allOperations));
            if (token.isCancellationRequested) {
                return false;
            }
            // In a perfect world, we should only apply edits if document is clean.
            if (version !== this.version) {
                console.error('onWillSave listeners should provide edits, not directly alter the document.');
            }
            // Finally apply edits provided by this listener before firing the next.
            if (edits && edits.length > 0) {
                this.applyEdits(edits, {
                    ignoreDirty: true,
                });
            }
            return true;
        });
        try {
            await firing;
        }
        catch (e) {
            console.error(e);
        }
    }
    fireDidSaveModel() {
        this.onDidSaveModelEmitter.fire(this.model);
    }
    async revert(options) {
        this.trace(log => log('MonacoEditorModel.revert - enter'));
        this.cancelSave();
        const soft = options && options.soft;
        if (soft !== true) {
            const dirty = this._dirty;
            this._dirty = false;
            try {
                await this.sync();
            }
            finally {
                this._dirty = dirty;
            }
        }
        this.setDirty(false);
        this.trace(log => log('MonacoEditorModel.revert - exit'));
    }
    createSnapshot() {
        return {
            value: this.getText()
        };
    }
    applySnapshot(snapshot) {
        this.model.setValue(snapshot.value);
    }
    trace(loggable) {
        if (this.logger) {
            this.logger.debug((log) => loggable((message, ...params) => log(message, ...params, this.resource.uri.toString(true))));
        }
    }
}
exports.MonacoEditorModel = MonacoEditorModel;


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/monaco-editor.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoEditor = exports.MonacoEditorServices = void 0;
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify.js");
const domutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/domutils */ "../node_modules/@theia/core/shared/@phosphor/domutils.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../node_modules/@theia/core/lib/browser/context-key-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const monaco_to_protocol_converter_1 = __webpack_require__(/*! ./monaco-to-protocol-converter */ "../node_modules/@theia/monaco/lib/browser/monaco-to-protocol-converter.js");
const protocol_to_monaco_converter_1 = __webpack_require__(/*! ./protocol-to-monaco-converter */ "../node_modules/@theia/monaco/lib/browser/protocol-to-monaco-converter.js");
const encodings_1 = __webpack_require__(/*! @theia/core/lib/common/encodings */ "../node_modules/@theia/core/lib/common/encodings.js");
let MonacoEditorServices = class MonacoEditorServices {
    constructor(services) {
        Object.assign(this, services);
    }
};
__decorate([
    inversify_1.inject(monaco_to_protocol_converter_1.MonacoToProtocolConverter),
    __metadata("design:type", monaco_to_protocol_converter_1.MonacoToProtocolConverter)
], MonacoEditorServices.prototype, "m2p", void 0);
__decorate([
    inversify_1.inject(protocol_to_monaco_converter_1.ProtocolToMonacoConverter),
    __metadata("design:type", protocol_to_monaco_converter_1.ProtocolToMonacoConverter)
], MonacoEditorServices.prototype, "p2m", void 0);
__decorate([
    inversify_1.inject(context_key_service_1.ContextKeyService),
    __metadata("design:type", context_key_service_1.ContextKeyService)
], MonacoEditorServices.prototype, "contextKeyService", void 0);
MonacoEditorServices = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.unmanaged()),
    __metadata("design:paramtypes", [MonacoEditorServices])
], MonacoEditorServices);
exports.MonacoEditorServices = MonacoEditorServices;
class MonacoEditor extends MonacoEditorServices {
    constructor(uri, document, node, services, options, override) {
        super(services);
        this.uri = uri;
        this.document = document;
        this.node = node;
        this.toDispose = new common_1.DisposableCollection();
        this.onCursorPositionChangedEmitter = new common_1.Emitter();
        this.onSelectionChangedEmitter = new common_1.Emitter();
        this.onFocusChangedEmitter = new common_1.Emitter();
        this.onDocumentContentChangedEmitter = new common_1.Emitter();
        this.onMouseDownEmitter = new common_1.Emitter();
        this.onLanguageChangedEmitter = new common_1.Emitter();
        this.onLanguageChanged = this.onLanguageChangedEmitter.event;
        this.onScrollChangedEmitter = new common_1.Emitter();
        this.onEncodingChanged = this.document.onDidChangeEncoding;
        // eslint-disable-next-line no-null/no-null
        this.onResizeEmitter = new common_1.Emitter();
        this.onDidResize = this.onResizeEmitter.event;
        this.documents = new Set();
        /* `true` because it is derived from an URI during the instantiation */
        this._languageAutoDetected = true;
        this.toDispose.pushAll([
            this.onCursorPositionChangedEmitter,
            this.onSelectionChangedEmitter,
            this.onFocusChangedEmitter,
            this.onDocumentContentChangedEmitter,
            this.onMouseDownEmitter,
            this.onLanguageChangedEmitter,
            this.onScrollChangedEmitter
        ]);
        this.documents.add(document);
        this.autoSizing = options && options.autoSizing !== undefined ? options.autoSizing : false;
        this.minHeight = options && options.minHeight !== undefined ? options.minHeight : -1;
        this.maxHeight = options && options.maxHeight !== undefined ? options.maxHeight : -1;
        this.toDispose.push(this.create(options, override));
        this.addHandlers(this.editor);
    }
    getEncoding() {
        return this.document.getEncoding() || encodings_1.UTF8;
    }
    setEncoding(encoding, mode) {
        return this.document.setEncoding(encoding, mode);
    }
    create(options, override) {
        return this.editor = monaco.editor.create(this.node, Object.assign(Object.assign({}, options), { lightbulb: { enabled: true }, fixedOverflowWidgets: true, scrollbar: {
                useShadows: false,
                verticalHasArrows: false,
                horizontalHasArrows: false,
                verticalScrollbarSize: 10,
                horizontalScrollbarSize: 10
            } }), override);
    }
    addHandlers(codeEditor) {
        this.toDispose.push(codeEditor.onDidChangeModelLanguage(e => this.fireLanguageChanged(e.newLanguage)));
        this.toDispose.push(codeEditor.onDidChangeConfiguration(() => this.refresh()));
        this.toDispose.push(codeEditor.onDidChangeModel(() => this.refresh()));
        this.toDispose.push(codeEditor.onDidChangeModelContent(e => {
            this.refresh();
            this.onDocumentContentChangedEmitter.fire({ document: this.document, contentChanges: e.changes.map(this.mapModelContentChange.bind(this)) });
        }));
        this.toDispose.push(codeEditor.onDidChangeCursorPosition(() => this.onCursorPositionChangedEmitter.fire(this.cursor)));
        this.toDispose.push(codeEditor.onDidChangeCursorSelection(() => this.onSelectionChangedEmitter.fire(this.selection)));
        this.toDispose.push(codeEditor.onDidFocusEditorText(() => this.onFocusChangedEmitter.fire(this.isFocused())));
        this.toDispose.push(codeEditor.onDidBlurEditorText(() => this.onFocusChangedEmitter.fire(this.isFocused())));
        this.toDispose.push(codeEditor.onMouseDown(e => {
            const { element, position, range } = e.target;
            this.onMouseDownEmitter.fire({
                target: Object.assign(Object.assign({}, e.target), { element: element || undefined, mouseColumn: this.m2p.asPosition(undefined, e.target.mouseColumn).character, range: range && this.m2p.asRange(range) || undefined, position: position && this.m2p.asPosition(position.lineNumber, position.column) || undefined }),
                event: e.event.browserEvent
            });
        }));
        this.toDispose.push(codeEditor.onDidScrollChange(e => {
            this.onScrollChangedEmitter.fire(undefined);
        }));
    }
    getVisibleRanges() {
        return this.editor.getVisibleRanges().map(range => this.m2p.asRange(range));
    }
    mapModelContentChange(change) {
        return {
            range: this.m2p.asRange(change.range),
            rangeLength: change.rangeLength,
            text: change.text
        };
    }
    get onDispose() {
        return this.toDispose.onDispose;
    }
    get onDocumentContentChanged() {
        return this.onDocumentContentChangedEmitter.event;
    }
    get cursor() {
        const { lineNumber, column } = this.editor.getPosition();
        return this.m2p.asPosition(lineNumber, column);
    }
    set cursor(cursor) {
        const position = this.p2m.asPosition(cursor);
        this.editor.setPosition(position);
    }
    get onCursorPositionChanged() {
        return this.onCursorPositionChangedEmitter.event;
    }
    get selection() {
        return this.m2p.asRange(this.editor.getSelection());
    }
    set selection(selection) {
        const range = this.p2m.asRange(selection);
        this.editor.setSelection(range);
    }
    get onSelectionChanged() {
        return this.onSelectionChangedEmitter.event;
    }
    get onScrollChanged() {
        return this.onScrollChangedEmitter.event;
    }
    revealPosition(raw, options = { vertical: 'center' }) {
        const position = this.p2m.asPosition(raw);
        switch (options.vertical) {
            case 'auto':
                this.editor.revealPosition(position);
                break;
            case 'center':
                this.editor.revealPositionInCenter(position);
                break;
            case 'centerIfOutsideViewport':
                this.editor.revealPositionInCenterIfOutsideViewport(position);
                break;
        }
    }
    revealRange(raw, options = { at: 'center' }) {
        const range = this.p2m.asRange(raw);
        switch (options.at) {
            case 'top':
                this.editor.revealRangeAtTop(range);
                break;
            case 'center':
                this.editor.revealRangeInCenter(range);
                break;
            case 'centerIfOutsideViewport':
                this.editor.revealRangeInCenterIfOutsideViewport(range);
                break;
            case 'auto':
                this.editor.revealRange(range);
                break;
        }
    }
    focus() {
        /**
         * `this.editor.focus` forcefully changes the focus editor state,
         * regardless whether the textarea actually received the focus.
         * It could lead to issues like https://github.com/eclipse-theia/theia/issues/7902
         * Instead we focus the underlying textarea.
         */
        const node = this.editor.getDomNode();
        if (node) {
            const textarea = node.querySelector('textarea');
            textarea.focus();
        }
    }
    blur() {
        const node = this.editor.getDomNode();
        if (node) {
            const textarea = node.querySelector('textarea');
            textarea.blur();
        }
    }
    isFocused({ strict } = { strict: false }) {
        if (!this.editor.hasTextFocus()) {
            return false;
        }
        if (strict) {
            return !this.isSuggestWidgetVisible() && !this.isFindWidgetVisible() && !this.isRenameInputVisible();
        }
        return true;
    }
    get onFocusChanged() {
        return this.onFocusChangedEmitter.event;
    }
    get onMouseDown() {
        return this.onMouseDownEmitter.event;
    }
    /**
     * `true` if the suggest widget is visible in the editor. Otherwise, `false`.
     */
    isSuggestWidgetVisible() {
        return this.contextKeyService.match('suggestWidgetVisible', this.editor.getDomNode() || this.node);
    }
    /**
     * `true` if the find (and replace) widget is visible in the editor. Otherwise, `false`.
     */
    isFindWidgetVisible() {
        return this.contextKeyService.match('findWidgetVisible', this.editor.getDomNode() || this.node);
    }
    /**
     * `true` if the name rename refactoring input HTML element is visible. Otherwise, `false`.
     */
    isRenameInputVisible() {
        return this.contextKeyService.match('renameInputVisible', this.editor.getDomNode() || this.node);
    }
    dispose() {
        this.toDispose.dispose();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    trigger(source, handlerId, payload) {
        this.editor.trigger(source, handlerId, payload);
    }
    getControl() {
        return this.editor;
    }
    refresh() {
        this.autoresize();
    }
    resizeToFit() {
        this.autoresize();
        // eslint-disable-next-line no-null/no-null
        this.onResizeEmitter.fire(null);
    }
    setSize(dimension) {
        this.resize(dimension);
        this.onResizeEmitter.fire(dimension);
    }
    autoresize() {
        if (this.autoSizing) {
            // eslint-disable-next-line no-null/no-null
            this.resize(null);
        }
    }
    resize(dimension) {
        if (this.node) {
            const layoutSize = this.computeLayoutSize(this.node, dimension);
            this.editor.layout(layoutSize);
        }
    }
    computeLayoutSize(hostNode, dimension) {
        if (dimension && dimension.width >= 0 && dimension.height >= 0) {
            return dimension;
        }
        const boxSizing = domutils_1.ElementExt.boxSizing(hostNode);
        const width = (!dimension || dimension.width < 0) ?
            this.getWidth(hostNode, boxSizing) :
            dimension.width;
        const height = (!dimension || dimension.height < 0) ?
            this.getHeight(hostNode, boxSizing) :
            dimension.height;
        return { width, height };
    }
    getWidth(hostNode, boxSizing) {
        return hostNode.offsetWidth - boxSizing.horizontalSum;
    }
    getHeight(hostNode, boxSizing) {
        if (!this.autoSizing) {
            return hostNode.offsetHeight - boxSizing.verticalSum;
        }
        const lineHeight = this.editor.getOption(monaco.editor.EditorOption.lineHeight);
        const lineCount = this.editor.getModel().getLineCount();
        const contentHeight = lineHeight * lineCount;
        const horizontalScrollbarHeight = this.editor.getLayoutInfo().horizontalScrollbarHeight;
        const editorHeight = contentHeight + horizontalScrollbarHeight;
        if (this.minHeight >= 0) {
            const minHeight = lineHeight * this.minHeight + horizontalScrollbarHeight;
            if (editorHeight < minHeight) {
                return minHeight;
            }
        }
        if (this.maxHeight >= 0) {
            const maxHeight = lineHeight * this.maxHeight + horizontalScrollbarHeight;
            return Math.min(maxHeight, editorHeight);
        }
        return editorHeight;
    }
    isActionSupported(id) {
        const action = this.editor.getAction(id);
        return !!action && action.isSupported();
    }
    async runAction(id) {
        const action = this.editor.getAction(id);
        if (action && action.isSupported()) {
            await action.run();
        }
    }
    get commandService() {
        return this.editor._commandService;
    }
    get instantiationService() {
        return this.editor._instantiationService;
    }
    deltaDecorations(params) {
        const oldDecorations = params.oldDecorations;
        const newDecorations = this.toDeltaDecorations(params);
        return this.editor.deltaDecorations(oldDecorations, newDecorations);
    }
    toDeltaDecorations(params) {
        return params.newDecorations.map(decoration => (Object.assign(Object.assign({}, decoration), { range: this.p2m.asRange(decoration.range) })));
    }
    getLinesDecorations(startLineNumber, endLineNumber) {
        const toPosition = (line) => this.p2m.asPosition({ line, character: 0 });
        const start = toPosition(startLineNumber).lineNumber;
        const end = toPosition(endLineNumber).lineNumber;
        return this.editor
            .getModel()
            .getLinesDecorations(start, end)
            .map(this.toEditorDecoration.bind(this));
    }
    toEditorDecoration(decoration) {
        const range = this.m2p.asRange(decoration.range);
        const { id, options } = decoration;
        return {
            options,
            range,
            id
        };
    }
    getVisibleColumn(position) {
        return this.editor.getVisibleColumnFromPosition(this.p2m.asPosition(position));
    }
    async replaceText(params) {
        const edits = params.replaceOperations.map(param => {
            const range = monaco.Range.fromPositions(this.p2m.asPosition(param.range.start), this.p2m.asPosition(param.range.end));
            return {
                forceMoveMarkers: true,
                identifier: {
                    major: range.startLineNumber,
                    minor: range.startColumn
                },
                range,
                text: param.text
            };
        });
        return this.editor.executeEdits(params.source, edits);
    }
    executeEdits(edits) {
        return this.editor.executeEdits('MonacoEditor', this.p2m.asTextEdits(edits));
    }
    storeViewState() {
        return this.editor.saveViewState();
    }
    restoreViewState(state) {
        this.editor.restoreViewState(state);
    }
    get languageAutoDetected() {
        return this._languageAutoDetected;
    }
    async detectLanguage() {
        const modeService = monaco.services.StaticServices.modeService.get();
        const firstLine = this.document.textEditorModel.getLineContent(1);
        const model = this.getControl().getModel();
        const language = modeService.createByFilepathOrFirstLine(model && model.uri, firstLine);
        this.setLanguage(language.languageIdentifier.language);
        this._languageAutoDetected = true;
    }
    setLanguage(languageId) {
        for (const document of this.documents) {
            monaco.editor.setModelLanguage(document.textEditorModel, languageId);
        }
    }
    fireLanguageChanged(languageId) {
        this._languageAutoDetected = false;
        this.onLanguageChangedEmitter.fire(languageId);
    }
    getResourceUri() {
        return this.uri;
    }
    createMoveToUri(resourceUri) {
        return this.uri.withPath(resourceUri.path);
    }
}
exports.MonacoEditor = MonacoEditor;
(function (MonacoEditor) {
    function getAll(manager) {
        return manager.all.map(e => get(e)).filter(e => !!e);
    }
    MonacoEditor.getAll = getAll;
    function getCurrent(manager) {
        return get(manager.currentEditor);
    }
    MonacoEditor.getCurrent = getCurrent;
    function getActive(manager) {
        return get(manager.activeEditor);
    }
    MonacoEditor.getActive = getActive;
    function get(editorWidget) {
        if (editorWidget && editorWidget.editor instanceof MonacoEditor) {
            return editorWidget.editor;
        }
        return undefined;
    }
    MonacoEditor.get = get;
    function findByDocument(manager, document) {
        return getAll(manager).filter(editor => editor.documents.has(document));
    }
    MonacoEditor.findByDocument = findByDocument;
    function getWidgetFor(manager, control) {
        if (!control) {
            return undefined;
        }
        return manager.all.find(widget => {
            const editor = get(widget);
            return !!editor && editor.getControl() === control;
        });
    }
    MonacoEditor.getWidgetFor = getWidgetFor;
})(MonacoEditor = exports.MonacoEditor || (exports.MonacoEditor = {}));


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoTextModelService = exports.MonacoEditorModelFactory = void 0;
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco_editor_model_1 = __webpack_require__(/*! ./monaco-editor-model */ "../node_modules/@theia/monaco/lib/browser/monaco-editor-model.js");
const monaco_to_protocol_converter_1 = __webpack_require__(/*! ./monaco-to-protocol-converter */ "../node_modules/@theia/monaco/lib/browser/monaco-to-protocol-converter.js");
const protocol_to_monaco_converter_1 = __webpack_require__(/*! ./protocol-to-monaco-converter */ "../node_modules/@theia/monaco/lib/browser/protocol-to-monaco-converter.js");
const logger_1 = __webpack_require__(/*! @theia/core/lib/common/logger */ "../node_modules/@theia/core/lib/common/logger.js");
const application_protocol_1 = __webpack_require__(/*! @theia/core/lib/common/application-protocol */ "../node_modules/@theia/core/lib/common/application-protocol.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
exports.MonacoEditorModelFactory = Symbol('MonacoEditorModelFactory');
let MonacoTextModelService = class MonacoTextModelService {
    constructor() {
        this._ready = new promise_util_1.Deferred();
        /**
         * This component does some asynchronous work before being fully initialized.
         */
        this.ready = this._ready.promise;
        this._models = new core_1.ReferenceCollection(uri => this.loadModel(new uri_1.default(uri)));
        this.modelOptions = {
            'editor.tabSize': 'tabSize',
            'editor.insertSpaces': 'insertSpaces'
        };
    }
    init() {
        let isWindowsBackend = false;
        this.applicationServer.getBackendOS().then(os => {
            isWindowsBackend = os === core_1.OS.Type.Windows;
        }, () => undefined).then(() => this._ready.resolve());
        const staticServices = monaco.services.StaticServices;
        if (staticServices.resourcePropertiesService) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const original = staticServices.resourcePropertiesService.get();
            original.getEOL = () => {
                const eol = this.editorPreferences['files.eol'];
                if (eol) {
                    if (eol !== 'auto') {
                        return eol;
                    }
                }
                return isWindowsBackend ? '\r\n' : '\n';
            };
        }
    }
    get models() {
        return this._models.values();
    }
    get(uri) {
        return this._models.get(uri);
    }
    get onDidCreate() {
        return this._models.onDidCreate;
    }
    createModelReference(raw) {
        return this._models.acquire(raw.toString());
    }
    async loadModel(uri) {
        await this.ready;
        await this.editorPreferences.ready;
        const resource = await this.resourceProvider(uri);
        const model = await (await this.createModel(resource)).load();
        this.updateModel(model);
        model.textEditorModel.onDidChangeLanguage(() => this.updateModel(model));
        const disposable = this.editorPreferences.onPreferenceChanged(change => this.updateModel(model, change));
        model.onDispose(() => disposable.dispose());
        return model;
    }
    createModel(resource) {
        const factory = this.factories.getContributions().find(({ scheme }) => resource.uri.scheme === scheme);
        return factory ? factory.createModel(resource) : new monaco_editor_model_1.MonacoEditorModel(resource, this.m2p, this.p2m, this.logger, this.editorPreferences);
    }
    updateModel(model, change) {
        if (change) {
            if (!change.affects(model.uri, model.languageId)) {
                return;
            }
            if (change.preferenceName === 'editor.autoSave') {
                model.autoSave = this.editorPreferences.get('editor.autoSave', undefined, model.uri);
            }
            if (change.preferenceName === 'editor.autoSaveDelay') {
                model.autoSaveDelay = this.editorPreferences.get('editor.autoSaveDelay', undefined, model.uri);
            }
            const modelOption = this.modelOptions[change.preferenceName];
            if (modelOption) {
                const options = {};
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                options[modelOption] = change.newValue;
                model.textEditorModel.updateOptions(options);
            }
        }
        else {
            model.autoSave = this.editorPreferences.get('editor.autoSave', undefined, model.uri);
            model.autoSaveDelay = this.editorPreferences.get('editor.autoSaveDelay', undefined, model.uri);
            model.textEditorModel.updateOptions(this.getModelOptions(model));
        }
    }
    getModelOptions(arg) {
        const uri = typeof arg === 'string' ? arg : arg.uri;
        const overrideIdentifier = typeof arg === 'string' ? undefined : arg.languageId;
        return {
            tabSize: this.editorPreferences.get({ preferenceName: 'editor.tabSize', overrideIdentifier }, undefined, uri),
            insertSpaces: this.editorPreferences.get({ preferenceName: 'editor.insertSpaces', overrideIdentifier }, undefined, uri)
        };
    }
    registerTextModelContentProvider(scheme, provider) {
        return {
            dispose() {
                // no-op
            }
        };
    }
};
__decorate([
    inversify_1.inject(core_1.ResourceProvider),
    __metadata("design:type", Function)
], MonacoTextModelService.prototype, "resourceProvider", void 0);
__decorate([
    inversify_1.inject(browser_1.EditorPreferences),
    __metadata("design:type", Object)
], MonacoTextModelService.prototype, "editorPreferences", void 0);
__decorate([
    inversify_1.inject(monaco_to_protocol_converter_1.MonacoToProtocolConverter),
    __metadata("design:type", monaco_to_protocol_converter_1.MonacoToProtocolConverter)
], MonacoTextModelService.prototype, "m2p", void 0);
__decorate([
    inversify_1.inject(protocol_to_monaco_converter_1.ProtocolToMonacoConverter),
    __metadata("design:type", protocol_to_monaco_converter_1.ProtocolToMonacoConverter)
], MonacoTextModelService.prototype, "p2m", void 0);
__decorate([
    inversify_1.inject(core_1.ContributionProvider),
    inversify_1.named(exports.MonacoEditorModelFactory),
    __metadata("design:type", Object)
], MonacoTextModelService.prototype, "factories", void 0);
__decorate([
    inversify_1.inject(logger_1.ILogger),
    __metadata("design:type", Object)
], MonacoTextModelService.prototype, "logger", void 0);
__decorate([
    inversify_1.inject(application_protocol_1.ApplicationServer),
    __metadata("design:type", Object)
], MonacoTextModelService.prototype, "applicationServer", void 0);
__decorate([
    inversify_1.postConstruct(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MonacoTextModelService.prototype, "init", null);
MonacoTextModelService = __decorate([
    inversify_1.injectable()
], MonacoTextModelService);
exports.MonacoTextModelService = MonacoTextModelService;


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/monaco-to-protocol-converter.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/monaco-to-protocol-converter.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (C) 2020 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoToProtocolConverter = exports.MonacoRangeReplace = void 0;
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify.js");
;
var MonacoRangeReplace;
(function (MonacoRangeReplace) {
    function is(v) {
        return v.insert !== undefined;
    }
    MonacoRangeReplace.is = is;
})(MonacoRangeReplace = exports.MonacoRangeReplace || (exports.MonacoRangeReplace = {}));
let MonacoToProtocolConverter = class MonacoToProtocolConverter {
    asPosition(lineNumber, column) {
        const line = typeof lineNumber !== 'number' ? undefined : lineNumber - 1;
        const character = typeof column !== 'number' ? undefined : column - 1;
        return {
            line, character
        };
    }
    asRange(range) {
        if (range === undefined) {
            return undefined;
        }
        if (MonacoRangeReplace.is(range)) {
            return this.asRange(range.insert);
        }
        else {
            const start = this.asPosition(range.startLineNumber, range.startColumn);
            const end = this.asPosition(range.endLineNumber, range.endColumn);
            return {
                start, end
            };
        }
    }
};
MonacoToProtocolConverter = __decorate([
    inversify_1.injectable()
], MonacoToProtocolConverter);
exports.MonacoToProtocolConverter = MonacoToProtocolConverter;


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/monaco-workspace.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/monaco-workspace.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoWorkspace = exports.ResourceTextEdit = exports.ResourceFileEdit = exports.WorkspaceTextEdit = exports.WorkspaceFileEdit = void 0;
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../node_modules/@theia/core/lib/common/uri.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const browser_1 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../node_modules/@theia/filesystem/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../node_modules/@theia/editor/lib/browser/index.js");
const monaco_text_model_service_1 = __webpack_require__(/*! ./monaco-text-model-service */ "../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js");
const monaco_editor_1 = __webpack_require__(/*! ./monaco-editor */ "../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const browser_3 = __webpack_require__(/*! @theia/markers/lib/browser */ "../node_modules/@theia/markers/lib/browser/index.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../node_modules/@theia/filesystem/lib/browser/file-service.js");
var WorkspaceFileEdit;
(function (WorkspaceFileEdit) {
    function is(arg) {
        return ('oldUri' in arg && monaco.Uri.isUri(arg.oldUri)) ||
            ('newUri' in arg && monaco.Uri.isUri(arg.newUri));
    }
    WorkspaceFileEdit.is = is;
})(WorkspaceFileEdit = exports.WorkspaceFileEdit || (exports.WorkspaceFileEdit = {}));
var WorkspaceTextEdit;
(function (WorkspaceTextEdit) {
    function is(arg) {
        return !!arg && typeof arg === 'object'
            && 'resource' in arg
            && monaco.Uri.isUri(arg.resource)
            && 'edit' in arg
            && arg.edit !== null
            && typeof arg.edit === 'object';
    }
    WorkspaceTextEdit.is = is;
})(WorkspaceTextEdit = exports.WorkspaceTextEdit || (exports.WorkspaceTextEdit = {}));
var ResourceFileEdit;
(function (ResourceFileEdit) {
    function is(arg) {
        return typeof arg === 'object' && (('oldResource' in arg) && monaco.Uri.isUri(arg.oldResource)) ||
            ('newResource' in arg && monaco.Uri.isUri(arg.newResource));
    }
    ResourceFileEdit.is = is;
})(ResourceFileEdit = exports.ResourceFileEdit || (exports.ResourceFileEdit = {}));
var ResourceTextEdit;
(function (ResourceTextEdit) {
    function is(arg) {
        return ('resource' in arg && monaco.Uri.isUri(arg.resource));
    }
    ResourceTextEdit.is = is;
})(ResourceTextEdit = exports.ResourceTextEdit || (exports.ResourceTextEdit = {}));
let MonacoWorkspace = class MonacoWorkspace {
    constructor() {
        this.ready = new Promise(resolve => {
            this.resolveReady = resolve;
        });
        this.onDidOpenTextDocumentEmitter = new event_1.Emitter();
        this.onDidOpenTextDocument = this.onDidOpenTextDocumentEmitter.event;
        this.onDidCloseTextDocumentEmitter = new event_1.Emitter();
        this.onDidCloseTextDocument = this.onDidCloseTextDocumentEmitter.event;
        this.onDidChangeTextDocumentEmitter = new event_1.Emitter();
        this.onDidChangeTextDocument = this.onDidChangeTextDocumentEmitter.event;
        this.onWillSaveTextDocumentEmitter = new event_1.Emitter();
        this.onWillSaveTextDocument = this.onWillSaveTextDocumentEmitter.event;
        this.onDidSaveTextDocumentEmitter = new event_1.Emitter();
        this.onDidSaveTextDocument = this.onDidSaveTextDocumentEmitter.event;
        this.suppressedOpenIfDirty = [];
    }
    init() {
        this.resolveReady();
        for (const model of this.textModelService.models) {
            this.fireDidOpen(model);
        }
        this.textModelService.onDidCreate(model => this.fireDidOpen(model));
    }
    get textDocuments() {
        return this.textModelService.models;
    }
    getTextDocument(uri) {
        return this.textModelService.get(uri);
    }
    fireDidOpen(model) {
        this.doFireDidOpen(model);
        model.textEditorModel.onDidChangeLanguage(e => {
            this.problems.cleanAllMarkers(new uri_1.default(model.uri));
            model.setLanguageId(e.oldLanguage);
            try {
                this.fireDidClose(model);
            }
            finally {
                model.setLanguageId(undefined);
            }
            this.doFireDidOpen(model);
        });
        model.onDidChangeContent(event => this.fireDidChangeContent(event));
        model.onDidSaveModel(() => this.fireDidSave(model));
        model.onWillSaveModel(event => this.fireWillSave(event));
        model.onDirtyChanged(() => this.openEditorIfDirty(model));
        model.onDispose(() => this.fireDidClose(model));
    }
    doFireDidOpen(model) {
        this.onDidOpenTextDocumentEmitter.fire(model);
    }
    fireDidClose(model) {
        this.onDidCloseTextDocumentEmitter.fire(model);
    }
    fireDidChangeContent(event) {
        this.onDidChangeTextDocumentEmitter.fire(event);
    }
    fireWillSave(event) {
        this.onWillSaveTextDocumentEmitter.fire(event);
    }
    fireDidSave(model) {
        this.onDidSaveTextDocumentEmitter.fire(model);
    }
    openEditorIfDirty(model) {
        if (model.suppressOpenEditorWhenDirty || this.suppressedOpenIfDirty.indexOf(model) !== -1) {
            return;
        }
        if (model.dirty && monaco_editor_1.MonacoEditor.findByDocument(this.editorManager, model).length === 0) {
            // create a new reference to make sure the model is not disposed before it is
            // acquired by the editor, thus losing the changes that made it dirty.
            this.textModelService.createModelReference(model.textEditorModel.uri).then(ref => {
                (model.autoSave === 'on' ? new Promise(resolve => model.onDidSaveModel(resolve)) :
                    this.editorManager.open(new uri_1.default(model.uri), { mode: 'open' })).then(() => ref.dispose());
            });
        }
    }
    async suppressOpenIfDirty(model, cb) {
        this.suppressedOpenIfDirty.push(model);
        try {
            await cb();
        }
        finally {
            const i = this.suppressedOpenIfDirty.indexOf(model);
            if (i !== -1) {
                this.suppressedOpenIfDirty.splice(i, 1);
            }
        }
    }
    /**
     * Applies given edits to the given model.
     * The model is saved if no editors is opened for it.
     */
    applyBackgroundEdit(model, editOperations) {
        return this.suppressOpenIfDirty(model, async () => {
            const editor = monaco_editor_1.MonacoEditor.findByDocument(this.editorManager, model)[0];
            const cursorState = editor && editor.getControl().getSelections() || [];
            model.textEditorModel.pushStackElement();
            model.textEditorModel.pushEditOperations(cursorState, editOperations, () => cursorState);
            model.textEditorModel.pushStackElement();
            if (!editor) {
                await model.save();
            }
        });
    }
    async applyBulkEdit(edits) {
        try {
            let totalEdits = 0;
            let totalFiles = 0;
            const fileEdits = edits.filter(edit => edit instanceof monaco.editor.ResourceFileEdit);
            const textEdits = edits.filter(edit => edit instanceof monaco.editor.ResourceTextEdit);
            if (fileEdits.length > 0) {
                await this.performFileEdits(fileEdits);
            }
            if (textEdits.length > 0) {
                const result = await this.performTextEdits(textEdits);
                totalEdits += result.totalEdits;
                totalFiles += result.totalFiles;
            }
            const ariaSummary = this.getAriaSummary(totalEdits, totalFiles);
            return { ariaSummary, success: true };
        }
        catch (e) {
            console.error('Failed to apply Resource edits:', e);
            return {
                ariaSummary: `Error applying Resource edits: ${e.toString()}`,
                success: false
            };
        }
    }
    getAriaSummary(totalEdits, totalFiles) {
        if (totalEdits === 0) {
            return 'Made no edits';
        }
        if (totalEdits > 1 && totalFiles > 1) {
            return `Made ${totalEdits} text edits in ${totalFiles} files`;
        }
        return `Made ${totalEdits} text edits in one file`;
    }
    async performTextEdits(edits) {
        let totalEdits = 0;
        let totalFiles = 0;
        const resourceEdits = new Map();
        for (const edit of edits) {
            if (typeof edit.versionId === 'number') {
                const model = this.textModelService.get(edit.resource.toString());
                if (model && model.textEditorModel.getVersionId() !== edit.versionId) {
                    throw new Error(`${model.uri} has changed in the meantime`);
                }
            }
            const key = edit.resource.toString();
            let array = resourceEdits.get(key);
            if (!array) {
                array = [];
                resourceEdits.set(key, array);
            }
            array.push(edit);
        }
        const pending = [];
        for (const [key, value] of resourceEdits) {
            pending.push((async () => {
                const uri = monaco.Uri.parse(key);
                let eol;
                const editOperations = [];
                const minimalEdits = await monaco.services.StaticServices.editorWorkerService.get().computeMoreMinimalEdits(uri, value.map(v => v.textEdit));
                if (minimalEdits) {
                    for (const textEdit of minimalEdits) {
                        if (typeof textEdit.eol === 'number') {
                            eol = textEdit.eol;
                        }
                        if (monaco.Range.isEmpty(textEdit.range) && !textEdit.text) {
                            // skip no-op
                            continue;
                        }
                        editOperations.push({
                            forceMoveMarkers: false,
                            range: monaco.Range.lift(textEdit.range),
                            text: textEdit.text
                        });
                    }
                }
                if (!editOperations.length && eol === undefined) {
                    return;
                }
                const reference = await this.textModelService.createModelReference(uri);
                try {
                    const model = reference.object.textEditorModel;
                    const editor = monaco_editor_1.MonacoEditor.findByDocument(this.editorManager, reference.object)[0];
                    const cursorState = (editor === null || editor === void 0 ? void 0 : editor.getControl().getSelections()) || [];
                    // start a fresh operation
                    model.pushStackElement();
                    if (editOperations.length) {
                        model.pushEditOperations(cursorState, editOperations, () => cursorState);
                    }
                    if (eol !== undefined) {
                        model.pushEOL(eol);
                    }
                    // push again to make this change an undoable operation
                    model.pushStackElement();
                    totalFiles += 1;
                    totalEdits += editOperations.length;
                }
                finally {
                    reference.dispose();
                }
            })());
        }
        await Promise.all(pending);
        return { totalEdits, totalFiles };
    }
    async performFileEdits(edits) {
        for (const edit of edits) {
            const options = edit.options || {};
            if (edit.newResource && edit.oldResource) {
                // rename
                if (options.overwrite === undefined && options.ignoreIfExists && await this.fileService.exists(new uri_1.default(edit.newResource))) {
                    return; // not overwriting, but ignoring, and the target file exists
                }
                await this.fileService.move(new uri_1.default(edit.oldResource), new uri_1.default(edit.newResource), { overwrite: options.overwrite });
            }
            else if (!edit.newResource && edit.oldResource) {
                // delete file
                if (await this.fileService.exists(new uri_1.default(edit.oldResource))) {
                    let useTrash = this.filePreferences['files.enableTrash'];
                    if (useTrash && !(this.fileService.hasCapability(new uri_1.default(edit.oldResource), 4096 /* Trash */))) {
                        useTrash = false; // not supported by provider
                    }
                    await this.fileService.delete(new uri_1.default(edit.oldResource), { useTrash, recursive: options.recursive });
                }
                else if (!options.ignoreIfNotExists) {
                    throw new Error(`${edit.oldResource} does not exist and can not be deleted`);
                }
            }
            else if (edit.newResource && !edit.oldResource) {
                // create file
                if (options.overwrite === undefined && options.ignoreIfExists && await this.fileService.exists(new uri_1.default(edit.newResource))) {
                    return; // not overwriting, but ignoring, and the target file exists
                }
                await this.fileService.create(new uri_1.default(edit.newResource), undefined, { overwrite: options.overwrite });
            }
        }
    }
};
__decorate([
    inversify_1.inject(file_service_1.FileService),
    __metadata("design:type", file_service_1.FileService)
], MonacoWorkspace.prototype, "fileService", void 0);
__decorate([
    inversify_1.inject(browser_1.FileSystemPreferences),
    __metadata("design:type", Object)
], MonacoWorkspace.prototype, "filePreferences", void 0);
__decorate([
    inversify_1.inject(monaco_text_model_service_1.MonacoTextModelService),
    __metadata("design:type", monaco_text_model_service_1.MonacoTextModelService)
], MonacoWorkspace.prototype, "textModelService", void 0);
__decorate([
    inversify_1.inject(browser_2.EditorManager),
    __metadata("design:type", browser_2.EditorManager)
], MonacoWorkspace.prototype, "editorManager", void 0);
__decorate([
    inversify_1.inject(browser_3.ProblemManager),
    __metadata("design:type", browser_3.ProblemManager)
], MonacoWorkspace.prototype, "problems", void 0);
__decorate([
    inversify_1.postConstruct(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], MonacoWorkspace.prototype, "init", null);
MonacoWorkspace = __decorate([
    inversify_1.injectable()
], MonacoWorkspace);
exports.MonacoWorkspace = MonacoWorkspace;


/***/ }),

/***/ "../node_modules/@theia/monaco/lib/browser/protocol-to-monaco-converter.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@theia/monaco/lib/browser/protocol-to-monaco-converter.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (C) 2020 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolToMonacoConverter = void 0;
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../node_modules/@theia/core/shared/inversify.js");
let ProtocolToMonacoConverter = class ProtocolToMonacoConverter {
    asRange(range) {
        if (range === undefined) {
            return undefined;
        }
        const start = this.asPosition(range.start);
        const end = this.asPosition(range.end);
        if (start instanceof monaco.Position && end instanceof monaco.Position) {
            return new monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        const startLineNumber = !start || start.lineNumber === undefined ? undefined : start.lineNumber;
        const startColumn = !start || start.column === undefined ? undefined : start.column;
        const endLineNumber = !end || end.lineNumber === undefined ? undefined : end.lineNumber;
        const endColumn = !end || end.column === undefined ? undefined : end.column;
        return { startLineNumber, startColumn, endLineNumber, endColumn };
    }
    asPosition(position) {
        if (position === undefined) {
            return undefined;
        }
        const { line, character } = position;
        const lineNumber = line === undefined ? undefined : line + 1;
        const column = character === undefined ? undefined : character + 1;
        if (lineNumber !== undefined && column !== undefined) {
            return new monaco.Position(lineNumber, column);
        }
        return { lineNumber, column };
    }
    asLocation(item) {
        if (!item) {
            return undefined;
        }
        const uri = monaco.Uri.parse(item.uri);
        const range = this.asRange(item.range);
        return {
            uri, range
        };
    }
    asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        const range = this.asRange(edit.range);
        return {
            range,
            text: edit.newText
        };
    }
    asTextEdits(items) {
        if (!items) {
            return undefined;
        }
        return items.map(item => this.asTextEdit(item));
    }
    asSeverity(severity) {
        if (severity === 1) {
            return monaco.MarkerSeverity.Error;
        }
        if (severity === 2) {
            return monaco.MarkerSeverity.Warning;
        }
        if (severity === 3) {
            return monaco.MarkerSeverity.Info;
        }
        return monaco.MarkerSeverity.Hint;
    }
    asDiagnostics(diagnostics) {
        if (!diagnostics) {
            return undefined;
        }
        return diagnostics.map(diagnostic => this.asDiagnostic(diagnostic));
    }
    asDiagnostic(diagnostic) {
        return {
            code: typeof diagnostic.code === 'number' ? diagnostic.code.toString() : diagnostic.code,
            severity: this.asSeverity(diagnostic.severity),
            message: diagnostic.message,
            source: diagnostic.source,
            startLineNumber: diagnostic.range.start.line + 1,
            startColumn: diagnostic.range.start.character + 1,
            endLineNumber: diagnostic.range.end.line + 1,
            endColumn: diagnostic.range.end.character + 1,
            relatedInformation: this.asRelatedInformations(diagnostic.relatedInformation),
            tags: diagnostic.tags
        };
    }
    asRelatedInformations(relatedInformation) {
        if (!relatedInformation) {
            return undefined;
        }
        return relatedInformation.map(item => this.asRelatedInformation(item));
    }
    asRelatedInformation(relatedInformation) {
        return {
            resource: monaco.Uri.parse(relatedInformation.location.uri),
            startLineNumber: relatedInformation.location.range.start.line + 1,
            startColumn: relatedInformation.location.range.start.character + 1,
            endLineNumber: relatedInformation.location.range.end.line + 1,
            endColumn: relatedInformation.location.range.end.character + 1,
            message: relatedInformation.message
        };
    }
};
ProtocolToMonacoConverter = __decorate([
    inversify_1.injectable()
], ProtocolToMonacoConverter);
exports.ProtocolToMonacoConverter = ProtocolToMonacoConverter;


/***/ }),

/***/ "../node_modules/vscode-languageserver-protocol/node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/vscode-languageserver-protocol/node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */


var Position;

(function (Position) {
  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  function create(line, character) {
    return {
      line: line,
      character: character
    };
  }

  Position.create = create;
  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
  }

  Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */


var Range;

(function (Range) {
  function create(one, two, three, four) {
    if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
      return {
        start: Position.create(one, two),
        end: Position.create(three, four)
      };
    } else if (Position.is(one) && Position.is(two)) {
      return {
        start: one,
        end: two
      };
    } else {
      throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
    }
  }

  Range.create = create;
  /**
   * Checks whether the given literal conforms to the [Range](#Range) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
  }

  Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */


var Location;

(function (Location) {
  /**
   * Creates a Location literal.
   * @param uri The location's uri.
   * @param range The location's range.
   */
  function create(uri, range) {
    return {
      uri: uri,
      range: range
    };
  }

  Location.create = create;
  /**
   * Checks whether the given literal conforms to the [Location](#Location) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
  }

  Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */


var LocationLink;

(function (LocationLink) {
  /**
   * Creates a LocationLink literal.
   * @param targetUri The definition's uri.
   * @param targetRange The full range of the definition.
   * @param targetSelectionRange The span of the symbol definition at the target.
   * @param originSelectionRange The span of the symbol being defined in the originating source file.
   */
  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
    return {
      targetUri: targetUri,
      targetRange: targetRange,
      targetSelectionRange: targetSelectionRange,
      originSelectionRange: originSelectionRange
    };
  }

  LocationLink.create = create;
  /**
   * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
  }

  LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */


var Color;

(function (Color) {
  /**
   * Creates a new Color literal.
   */
  function create(red, green, blue, alpha) {
    return {
      red: red,
      green: green,
      blue: blue,
      alpha: alpha
    };
  }

  Color.create = create;
  /**
   * Checks whether the given literal conforms to the [Color](#Color) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.number(candidate.red) && Is.number(candidate.green) && Is.number(candidate.blue) && Is.number(candidate.alpha);
  }

  Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */


var ColorInformation;

(function (ColorInformation) {
  /**
   * Creates a new ColorInformation literal.
   */
  function create(range, color) {
    return {
      range: range,
      color: color
    };
  }

  ColorInformation.create = create;
  /**
   * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
   */

  function is(value) {
    var candidate = value;
    return Range.is(candidate.range) && Color.is(candidate.color);
  }

  ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */


var ColorPresentation;

(function (ColorPresentation) {
  /**
   * Creates a new ColorInformation literal.
   */
  function create(label, textEdit, additionalTextEdits) {
    return {
      label: label,
      textEdit: textEdit,
      additionalTextEdits: additionalTextEdits
    };
  }

  ColorPresentation.create = create;
  /**
   * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
  }

  ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */


var FoldingRangeKind;

(function (FoldingRangeKind) {
  /**
   * Folding range for a comment
   */
  FoldingRangeKind["Comment"] = "comment";
  /**
   * Folding range for a imports or includes
   */

  FoldingRangeKind["Imports"] = "imports";
  /**
   * Folding range for a region (e.g. `#region`)
   */

  FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */


var FoldingRange;

(function (FoldingRange) {
  /**
   * Creates a new FoldingRange literal.
   */
  function create(startLine, endLine, startCharacter, endCharacter, kind) {
    var result = {
      startLine: startLine,
      endLine: endLine
    };

    if (Is.defined(startCharacter)) {
      result.startCharacter = startCharacter;
    }

    if (Is.defined(endCharacter)) {
      result.endCharacter = endCharacter;
    }

    if (Is.defined(kind)) {
      result.kind = kind;
    }

    return result;
  }

  FoldingRange.create = create;
  /**
   * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.number(candidate.startLine) && Is.number(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
  }

  FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */


var DiagnosticRelatedInformation;

(function (DiagnosticRelatedInformation) {
  /**
   * Creates a new DiagnosticRelatedInformation literal.
   */
  function create(location, message) {
    return {
      location: location,
      message: message
    };
  }

  DiagnosticRelatedInformation.create = create;
  /**
   * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
  }

  DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */


var DiagnosticSeverity;

(function (DiagnosticSeverity) {
  /**
   * Reports an error.
   */
  DiagnosticSeverity.Error = 1;
  /**
   * Reports a warning.
   */

  DiagnosticSeverity.Warning = 2;
  /**
   * Reports an information.
   */

  DiagnosticSeverity.Information = 3;
  /**
   * Reports a hint.
   */

  DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */


var DiagnosticTag;

(function (DiagnosticTag) {
  /**
   * Unused or unnecessary code.
   *
   * Clients are allowed to render diagnostics with this tag faded out instead of having
   * an error squiggle.
   */
  DiagnosticTag.Unnecessary = 1;
  /**
   * Deprecated or obsolete code.
   *
   * Clients are allowed to rendered diagnostics with this tag strike through.
   */

  DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */


var Diagnostic;

(function (Diagnostic) {
  /**
   * Creates a new Diagnostic literal.
   */
  function create(range, message, severity, code, source, relatedInformation) {
    var result = {
      range: range,
      message: message
    };

    if (Is.defined(severity)) {
      result.severity = severity;
    }

    if (Is.defined(code)) {
      result.code = code;
    }

    if (Is.defined(source)) {
      result.source = source;
    }

    if (Is.defined(relatedInformation)) {
      result.relatedInformation = relatedInformation;
    }

    return result;
  }

  Diagnostic.create = create;
  /**
   * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
  }

  Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */


var Command;

(function (Command) {
  /**
   * Creates a new Command literal.
   */
  function create(title, command) {
    var args = [];

    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }

    var result = {
      title: title,
      command: command
    };

    if (Is.defined(args) && args.length > 0) {
      result.arguments = args;
    }

    return result;
  }

  Command.create = create;
  /**
   * Checks whether the given literal conforms to the [Command](#Command) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
  }

  Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */


var TextEdit;

(function (TextEdit) {
  /**
   * Creates a replace text edit.
   * @param range The range of text to be replaced.
   * @param newText The new text.
   */
  function replace(range, newText) {
    return {
      range: range,
      newText: newText
    };
  }

  TextEdit.replace = replace;
  /**
   * Creates a insert text edit.
   * @param position The position to insert the text at.
   * @param newText The text to be inserted.
   */

  function insert(position, newText) {
    return {
      range: {
        start: position,
        end: position
      },
      newText: newText
    };
  }

  TextEdit.insert = insert;
  /**
   * Creates a delete text edit.
   * @param range The range of text to be deleted.
   */

  function del(range) {
    return {
      range: range,
      newText: ''
    };
  }

  TextEdit.del = del;

  function is(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
  }

  TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */


var TextDocumentEdit;

(function (TextDocumentEdit) {
  /**
   * Creates a new `TextDocumentEdit`
   */
  function create(textDocument, edits) {
    return {
      textDocument: textDocument,
      edits: edits
    };
  }

  TextDocumentEdit.create = create;

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && VersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
  }

  TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));

var CreateFile;

(function (CreateFile) {
  function create(uri, options) {
    var result = {
      kind: 'create',
      uri: uri
    };

    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }

    return result;
  }

  CreateFile.create = create;

  function is(value) {
    var candidate = value;
    return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is["boolean"](candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is["boolean"](candidate.options.ignoreIfExists)));
  }

  CreateFile.is = is;
})(CreateFile || (CreateFile = {}));

var RenameFile;

(function (RenameFile) {
  function create(oldUri, newUri, options) {
    var result = {
      kind: 'rename',
      oldUri: oldUri,
      newUri: newUri
    };

    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }

    return result;
  }

  RenameFile.create = create;

  function is(value) {
    var candidate = value;
    return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is["boolean"](candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is["boolean"](candidate.options.ignoreIfExists)));
  }

  RenameFile.is = is;
})(RenameFile || (RenameFile = {}));

var DeleteFile;

(function (DeleteFile) {
  function create(uri, options) {
    var result = {
      kind: 'delete',
      uri: uri
    };

    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
      result.options = options;
    }

    return result;
  }

  DeleteFile.create = create;

  function is(value) {
    var candidate = value;
    return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is["boolean"](candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is["boolean"](candidate.options.ignoreIfNotExists)));
  }

  DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));

var WorkspaceEdit;

(function (WorkspaceEdit) {
  function is(value) {
    var candidate = value;
    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {
      if (Is.string(change.kind)) {
        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
      } else {
        return TextDocumentEdit.is(change);
      }
    }));
  }

  WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));

var TextEditChangeImpl = function () {
  function TextEditChangeImpl(edits) {
    this.edits = edits;
  }

  TextEditChangeImpl.prototype.insert = function (position, newText) {
    this.edits.push(TextEdit.insert(position, newText));
  };

  TextEditChangeImpl.prototype.replace = function (range, newText) {
    this.edits.push(TextEdit.replace(range, newText));
  };

  TextEditChangeImpl.prototype["delete"] = function (range) {
    this.edits.push(TextEdit.del(range));
  };

  TextEditChangeImpl.prototype.add = function (edit) {
    this.edits.push(edit);
  };

  TextEditChangeImpl.prototype.all = function () {
    return this.edits;
  };

  TextEditChangeImpl.prototype.clear = function () {
    this.edits.splice(0, this.edits.length);
  };

  return TextEditChangeImpl;
}();
/**
 * A workspace change helps constructing changes to a workspace.
 */


var WorkspaceChange = function () {
  function WorkspaceChange(workspaceEdit) {
    var _this = this;

    this._textEditChanges = Object.create(null);

    if (workspaceEdit) {
      this._workspaceEdit = workspaceEdit;

      if (workspaceEdit.documentChanges) {
        workspaceEdit.documentChanges.forEach(function (change) {
          if (TextDocumentEdit.is(change)) {
            var textEditChange = new TextEditChangeImpl(change.edits);
            _this._textEditChanges[change.textDocument.uri] = textEditChange;
          }
        });
      } else if (workspaceEdit.changes) {
        Object.keys(workspaceEdit.changes).forEach(function (key) {
          var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
          _this._textEditChanges[key] = textEditChange;
        });
      }
    }
  }

  Object.defineProperty(WorkspaceChange.prototype, "edit", {
    /**
     * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
     * use to be returned from a workspace edit operation like rename.
     */
    get: function get() {
      return this._workspaceEdit;
    },
    enumerable: true,
    configurable: true
  });

  WorkspaceChange.prototype.getTextEditChange = function (key) {
    if (VersionedTextDocumentIdentifier.is(key)) {
      if (!this._workspaceEdit) {
        this._workspaceEdit = {
          documentChanges: []
        };
      }

      if (!this._workspaceEdit.documentChanges) {
        throw new Error('Workspace edit is not configured for document changes.');
      }

      var textDocument = key;
      var result = this._textEditChanges[textDocument.uri];

      if (!result) {
        var edits = [];
        var textDocumentEdit = {
          textDocument: textDocument,
          edits: edits
        };

        this._workspaceEdit.documentChanges.push(textDocumentEdit);

        result = new TextEditChangeImpl(edits);
        this._textEditChanges[textDocument.uri] = result;
      }

      return result;
    } else {
      if (!this._workspaceEdit) {
        this._workspaceEdit = {
          changes: Object.create(null)
        };
      }

      if (!this._workspaceEdit.changes) {
        throw new Error('Workspace edit is not configured for normal text edit changes.');
      }

      var result = this._textEditChanges[key];

      if (!result) {
        var edits = [];
        this._workspaceEdit.changes[key] = edits;
        result = new TextEditChangeImpl(edits);
        this._textEditChanges[key] = result;
      }

      return result;
    }
  };

  WorkspaceChange.prototype.createFile = function (uri, options) {
    this.checkDocumentChanges();

    this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
  };

  WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {
    this.checkDocumentChanges();

    this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
  };

  WorkspaceChange.prototype.deleteFile = function (uri, options) {
    this.checkDocumentChanges();

    this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
  };

  WorkspaceChange.prototype.checkDocumentChanges = function () {
    if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
      throw new Error('Workspace edit is not configured for document changes.');
    }
  };

  return WorkspaceChange;
}();


/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */

var TextDocumentIdentifier;

(function (TextDocumentIdentifier) {
  /**
   * Creates a new TextDocumentIdentifier literal.
   * @param uri The document's uri.
   */
  function create(uri) {
    return {
      uri: uri
    };
  }

  TextDocumentIdentifier.create = create;
  /**
   * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri);
  }

  TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */


var VersionedTextDocumentIdentifier;

(function (VersionedTextDocumentIdentifier) {
  /**
   * Creates a new VersionedTextDocumentIdentifier literal.
   * @param uri The document's uri.
   * @param uri The document's text.
   */
  function create(uri, version) {
    return {
      uri: uri,
      version: version
    };
  }

  VersionedTextDocumentIdentifier.create = create;
  /**
   * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
  }

  VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */


var TextDocumentItem;

(function (TextDocumentItem) {
  /**
   * Creates a new TextDocumentItem literal.
   * @param uri The document's uri.
   * @param languageId The document's language identifier.
   * @param version The document's version number.
   * @param text The document's text.
   */
  function create(uri, languageId, version, text) {
    return {
      uri: uri,
      languageId: languageId,
      version: version,
      text: text
    };
  }

  TextDocumentItem.create = create;
  /**
   * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
  }

  TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */


var MarkupKind;

(function (MarkupKind) {
  /**
   * Plain text is supported as a content format
   */
  MarkupKind.PlainText = 'plaintext';
  /**
   * Markdown is supported as a content format
   */

  MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));

(function (MarkupKind) {
  /**
   * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
   */
  function is(value) {
    var candidate = value;
    return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
  }

  MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));

var MarkupContent;

(function (MarkupContent) {
  /**
   * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
   */
  function is(value) {
    var candidate = value;
    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
  }

  MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */


var CompletionItemKind;

(function (CompletionItemKind) {
  CompletionItemKind.Text = 1;
  CompletionItemKind.Method = 2;
  CompletionItemKind.Function = 3;
  CompletionItemKind.Constructor = 4;
  CompletionItemKind.Field = 5;
  CompletionItemKind.Variable = 6;
  CompletionItemKind.Class = 7;
  CompletionItemKind.Interface = 8;
  CompletionItemKind.Module = 9;
  CompletionItemKind.Property = 10;
  CompletionItemKind.Unit = 11;
  CompletionItemKind.Value = 12;
  CompletionItemKind.Enum = 13;
  CompletionItemKind.Keyword = 14;
  CompletionItemKind.Snippet = 15;
  CompletionItemKind.Color = 16;
  CompletionItemKind.File = 17;
  CompletionItemKind.Reference = 18;
  CompletionItemKind.Folder = 19;
  CompletionItemKind.EnumMember = 20;
  CompletionItemKind.Constant = 21;
  CompletionItemKind.Struct = 22;
  CompletionItemKind.Event = 23;
  CompletionItemKind.Operator = 24;
  CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */


var InsertTextFormat;

(function (InsertTextFormat) {
  /**
   * The primary text to be inserted is treated as a plain string.
   */
  InsertTextFormat.PlainText = 1;
  /**
   * The primary text to be inserted is treated as a snippet.
   *
   * A snippet can define tab stops and placeholders with `$1`, `$2`
   * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
   * the end of the snippet. Placeholders with equal identifiers are linked,
   * that is typing in one will update others too.
   *
   * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
   */

  InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */


var CompletionItemTag;

(function (CompletionItemTag) {
  /**
   * Render a completion as obsolete, usually using a strike-out.
   */
  CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */


var CompletionItem;

(function (CompletionItem) {
  /**
   * Create a completion item and seed it with a label.
   * @param label The completion item's label
   */
  function create(label) {
    return {
      label: label
    };
  }

  CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */


var CompletionList;

(function (CompletionList) {
  /**
   * Creates a new completion list.
   *
   * @param items The completion items.
   * @param isIncomplete The list is not complete.
   */
  function create(items, isIncomplete) {
    return {
      items: items ? items : [],
      isIncomplete: !!isIncomplete
    };
  }

  CompletionList.create = create;
})(CompletionList || (CompletionList = {}));

var MarkedString;

(function (MarkedString) {
  /**
   * Creates a marked string from plain text.
   *
   * @param plainText The plain text.
   */
  function fromPlainText(plainText) {
    return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
  }

  MarkedString.fromPlainText = fromPlainText;
  /**
   * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
   */

  function is(value) {
    var candidate = value;
    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
  }

  MarkedString.is = is;
})(MarkedString || (MarkedString = {}));

var Hover;

(function (Hover) {
  /**
   * Checks whether the given value conforms to the [Hover](#Hover) interface.
   */
  function is(value) {
    var candidate = value;
    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
  }

  Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */


var ParameterInformation;

(function (ParameterInformation) {
  /**
   * Creates a new parameter information literal.
   *
   * @param label A label string.
   * @param documentation A doc string.
   */
  function create(label, documentation) {
    return documentation ? {
      label: label,
      documentation: documentation
    } : {
      label: label
    };
  }

  ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */


var SignatureInformation;

(function (SignatureInformation) {
  function create(label, documentation) {
    var parameters = [];

    for (var _i = 2; _i < arguments.length; _i++) {
      parameters[_i - 2] = arguments[_i];
    }

    var result = {
      label: label
    };

    if (Is.defined(documentation)) {
      result.documentation = documentation;
    }

    if (Is.defined(parameters)) {
      result.parameters = parameters;
    } else {
      result.parameters = [];
    }

    return result;
  }

  SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */


var DocumentHighlightKind;

(function (DocumentHighlightKind) {
  /**
   * A textual occurrence.
   */
  DocumentHighlightKind.Text = 1;
  /**
   * Read-access of a symbol, like reading a variable.
   */

  DocumentHighlightKind.Read = 2;
  /**
   * Write-access of a symbol, like writing to a variable.
   */

  DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */


var DocumentHighlight;

(function (DocumentHighlight) {
  /**
   * Create a DocumentHighlight object.
   * @param range The range the highlight applies to.
   */
  function create(range, kind) {
    var result = {
      range: range
    };

    if (Is.number(kind)) {
      result.kind = kind;
    }

    return result;
  }

  DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */


var SymbolKind;

(function (SymbolKind) {
  SymbolKind.File = 1;
  SymbolKind.Module = 2;
  SymbolKind.Namespace = 3;
  SymbolKind.Package = 4;
  SymbolKind.Class = 5;
  SymbolKind.Method = 6;
  SymbolKind.Property = 7;
  SymbolKind.Field = 8;
  SymbolKind.Constructor = 9;
  SymbolKind.Enum = 10;
  SymbolKind.Interface = 11;
  SymbolKind.Function = 12;
  SymbolKind.Variable = 13;
  SymbolKind.Constant = 14;
  SymbolKind.String = 15;
  SymbolKind.Number = 16;
  SymbolKind.Boolean = 17;
  SymbolKind.Array = 18;
  SymbolKind.Object = 19;
  SymbolKind.Key = 20;
  SymbolKind.Null = 21;
  SymbolKind.EnumMember = 22;
  SymbolKind.Struct = 23;
  SymbolKind.Event = 24;
  SymbolKind.Operator = 25;
  SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.15
 */


var SymbolTag;

(function (SymbolTag) {
  /**
   * Render a symbol as obsolete, usually using a strike-out.
   */
  SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));

var SymbolInformation;

(function (SymbolInformation) {
  /**
   * Creates a new symbol information literal.
   *
   * @param name The name of the symbol.
   * @param kind The kind of the symbol.
   * @param range The range of the location of the symbol.
   * @param uri The resource of the location of symbol, defaults to the current document.
   * @param containerName The name of the symbol containing the symbol.
   */
  function create(name, kind, range, uri, containerName) {
    var result = {
      name: name,
      kind: kind,
      location: {
        uri: uri,
        range: range
      }
    };

    if (containerName) {
      result.containerName = containerName;
    }

    return result;
  }

  SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));

var DocumentSymbol;

(function (DocumentSymbol) {
  /**
   * Creates a new symbol information literal.
   *
   * @param name The name of the symbol.
   * @param detail The detail of the symbol.
   * @param kind The kind of the symbol.
   * @param range The range of the symbol.
   * @param selectionRange The selectionRange of the symbol.
   * @param children Children of the symbol.
   */
  function create(name, detail, kind, range, selectionRange, children) {
    var result = {
      name: name,
      detail: detail,
      kind: kind,
      range: range,
      selectionRange: selectionRange
    };

    if (children !== void 0) {
      result.children = children;
    }

    return result;
  }

  DocumentSymbol.create = create;
  /**
   * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
   */

  function is(value) {
    var candidate = value;
    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is["boolean"](candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children));
  }

  DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */


var CodeActionKind;

(function (CodeActionKind) {
  /**
   * Empty kind.
   */
  CodeActionKind.Empty = '';
  /**
   * Base kind for quickfix actions: 'quickfix'
   */

  CodeActionKind.QuickFix = 'quickfix';
  /**
   * Base kind for refactoring actions: 'refactor'
   */

  CodeActionKind.Refactor = 'refactor';
  /**
   * Base kind for refactoring extraction actions: 'refactor.extract'
   *
   * Example extract actions:
   *
   * - Extract method
   * - Extract function
   * - Extract variable
   * - Extract interface from class
   * - ...
   */

  CodeActionKind.RefactorExtract = 'refactor.extract';
  /**
   * Base kind for refactoring inline actions: 'refactor.inline'
   *
   * Example inline actions:
   *
   * - Inline function
   * - Inline variable
   * - Inline constant
   * - ...
   */

  CodeActionKind.RefactorInline = 'refactor.inline';
  /**
   * Base kind for refactoring rewrite actions: 'refactor.rewrite'
   *
   * Example rewrite actions:
   *
   * - Convert JavaScript function to class
   * - Add or remove parameter
   * - Encapsulate field
   * - Make method static
   * - Move method to base class
   * - ...
   */

  CodeActionKind.RefactorRewrite = 'refactor.rewrite';
  /**
   * Base kind for source actions: `source`
   *
   * Source code actions apply to the entire file.
   */

  CodeActionKind.Source = 'source';
  /**
   * Base kind for an organize imports source action: `source.organizeImports`
   */

  CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
  /**
   * Base kind for auto-fix source actions: `source.fixAll`.
   *
   * Fix all actions automatically fix errors that have a clear fix that do not require user input.
   * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
   *
   * @since 3.15.0
   */

  CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */


var CodeActionContext;

(function (CodeActionContext) {
  /**
   * Creates a new CodeActionContext literal.
   */
  function create(diagnostics, only) {
    var result = {
      diagnostics: diagnostics
    };

    if (only !== void 0 && only !== null) {
      result.only = only;
    }

    return result;
  }

  CodeActionContext.create = create;
  /**
   * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
  }

  CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));

var CodeAction;

(function (CodeAction) {
  function create(title, commandOrEdit, kind) {
    var result = {
      title: title
    };

    if (Command.is(commandOrEdit)) {
      result.command = commandOrEdit;
    } else {
      result.edit = commandOrEdit;
    }

    if (kind !== void 0) {
      result.kind = kind;
    }

    return result;
  }

  CodeAction.create = create;

  function is(value) {
    var candidate = value;
    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is["boolean"](candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
  }

  CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */


var CodeLens;

(function (CodeLens) {
  /**
   * Creates a new CodeLens literal.
   */
  function create(range, data) {
    var result = {
      range: range
    };

    if (Is.defined(data)) {
      result.data = data;
    }

    return result;
  }

  CodeLens.create = create;
  /**
   * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
  }

  CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */


var FormattingOptions;

(function (FormattingOptions) {
  /**
   * Creates a new FormattingOptions literal.
   */
  function create(tabSize, insertSpaces) {
    return {
      tabSize: tabSize,
      insertSpaces: insertSpaces
    };
  }

  FormattingOptions.create = create;
  /**
   * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.number(candidate.tabSize) && Is["boolean"](candidate.insertSpaces);
  }

  FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */


var DocumentLink;

(function (DocumentLink) {
  /**
   * Creates a new DocumentLink literal.
   */
  function create(range, target, data) {
    return {
      range: range,
      target: target,
      data: data
    };
  }

  DocumentLink.create = create;
  /**
   * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
  }

  DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */


var SelectionRange;

(function (SelectionRange) {
  /**
   * Creates a new SelectionRange
   * @param range the range.
   * @param parent an optional parent.
   */
  function create(range, parent) {
    return {
      range: range,
      parent: parent
    };
  }

  SelectionRange.create = create;

  function is(value) {
    var candidate = value;
    return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
  }

  SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));

var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */

var TextDocument;

(function (TextDocument) {
  /**
   * Creates a new ITextDocument literal from the given uri and content.
   * @param uri The document's uri.
   * @param languageId  The document's language Id.
   * @param content The document's content.
   */
  function create(uri, languageId, version, content) {
    return new FullTextDocument(uri, languageId, version, content);
  }

  TextDocument.create = create;
  /**
   * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
   */

  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
  }

  TextDocument.is = is;

  function applyEdits(document, edits) {
    var text = document.getText();
    var sortedEdits = mergeSort(edits, function (a, b) {
      var diff = a.range.start.line - b.range.start.line;

      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }

      return diff;
    });
    var lastModifiedOffset = text.length;

    for (var i = sortedEdits.length - 1; i >= 0; i--) {
      var e = sortedEdits[i];
      var startOffset = document.offsetAt(e.range.start);
      var endOffset = document.offsetAt(e.range.end);

      if (endOffset <= lastModifiedOffset) {
        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
      } else {
        throw new Error('Overlapping edit');
      }

      lastModifiedOffset = startOffset;
    }

    return text;
  }

  TextDocument.applyEdits = applyEdits;

  function mergeSort(data, compare) {
    if (data.length <= 1) {
      // sorted
      return data;
    }

    var p = data.length / 2 | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;

    while (leftIdx < left.length && rightIdx < right.length) {
      var ret = compare(left[leftIdx], right[rightIdx]);

      if (ret <= 0) {
        // smaller_equal -> take left to preserve order
        data[i++] = left[leftIdx++];
      } else {
        // greater -> take right
        data[i++] = right[rightIdx++];
      }
    }

    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }

    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }

    return data;
  }
})(TextDocument || (TextDocument = {}));

var FullTextDocument = function () {
  function FullTextDocument(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = undefined;
  }

  Object.defineProperty(FullTextDocument.prototype, "uri", {
    get: function get() {
      return this._uri;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FullTextDocument.prototype, "languageId", {
    get: function get() {
      return this._languageId;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FullTextDocument.prototype, "version", {
    get: function get() {
      return this._version;
    },
    enumerable: true,
    configurable: true
  });

  FullTextDocument.prototype.getText = function (range) {
    if (range) {
      var start = this.offsetAt(range.start);
      var end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }

    return this._content;
  };

  FullTextDocument.prototype.update = function (event, version) {
    this._content = event.text;
    this._version = version;
    this._lineOffsets = undefined;
  };

  FullTextDocument.prototype.getLineOffsets = function () {
    if (this._lineOffsets === undefined) {
      var lineOffsets = [];
      var text = this._content;
      var isLineStart = true;

      for (var i = 0; i < text.length; i++) {
        if (isLineStart) {
          lineOffsets.push(i);
          isLineStart = false;
        }

        var ch = text.charAt(i);
        isLineStart = ch === '\r' || ch === '\n';

        if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
          i++;
        }
      }

      if (isLineStart && text.length > 0) {
        lineOffsets.push(text.length);
      }

      this._lineOffsets = lineOffsets;
    }

    return this._lineOffsets;
  };

  FullTextDocument.prototype.positionAt = function (offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    var lineOffsets = this.getLineOffsets();
    var low = 0,
        high = lineOffsets.length;

    if (high === 0) {
      return Position.create(0, offset);
    }

    while (low < high) {
      var mid = Math.floor((low + high) / 2);

      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    } // low is the least x for which the line offset is larger than the current offset
    // or array.length if no line offset is larger than the current offset


    var line = low - 1;
    return Position.create(line, offset - lineOffsets[line]);
  };

  FullTextDocument.prototype.offsetAt = function (position) {
    var lineOffsets = this.getLineOffsets();

    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }

    var lineOffset = lineOffsets[position.line];
    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  };

  Object.defineProperty(FullTextDocument.prototype, "lineCount", {
    get: function get() {
      return this.getLineOffsets().length;
    },
    enumerable: true,
    configurable: true
  });
  return FullTextDocument;
}();

var Is;

(function (Is) {
  var toString = Object.prototype.toString;

  function defined(value) {
    return typeof value !== 'undefined';
  }

  Is.defined = defined;

  function undefined(value) {
    return typeof value === 'undefined';
  }

  Is.undefined = undefined;

  function _boolean(value) {
    return value === true || value === false;
  }

  Is["boolean"] = _boolean;

  function string(value) {
    return toString.call(value) === '[object String]';
  }

  Is.string = string;

  function number(value) {
    return toString.call(value) === '[object Number]';
  }

  Is.number = number;

  function func(value) {
    return toString.call(value) === '[object Function]';
  }

  Is.func = func;

  function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(value) === 'object';
  }

  Is.objectLiteral = objectLiteral;

  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }

  Is.typedArray = typedArray;
})(Is || (Is = {}));

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_theia_monaco_lib_browser_monaco-workspace_js.bundle.js.map