{
	"AbstractFactory":{"description":"Abstract Factory lets you produce families of related objects without specifying their concrete classes.","example":"Example: Consider a case that you want to develop a system that creates various types of furniture (e.g., Chairs and Sofas). Furniture belong to two families (e.g., Victorian and Modern. For each family, a dedicated factory class is developed, being responsible for creating the concrete type of each product."},
	"Builder":{"description":"Builder is a creational design pattern that lets you construct complex objects step by step (by ConcreteBuilders methods). The pattern allows you to produce different types and representations of an object (Product) using the same construction code.","example":"Example: Consider a case that you want to build cars and their manuals. The client can delegate the assembly to the director class, which knows how to use a builder to construct several models of cars. As a car model diverse from another, the same way a manual diverse from car to car. So you can use the same builder for constructing both Car and Manual, but you need another ConcreteBuilder (CarManualBuilder) to describe car parts. Finally, you get from the ConcreteBuilders the final products (Car and Manual)."},
	"FactoryMethod":{"description":"Factory Method provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects (ConcreteProducts) that will be created.","example":"Factory Method can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes. ConcreteCreators (WindowsDialog and WebDialog) override the base factory method (Dialog) so it returns a different type of product (WindowsButton or WebButton)."},
	"Prototype":{"description":"Prototype lets you copy existing objects without making your code dependent on their classes.","example":"Example: Consider the case that you want to produce exact copies of geometric objects, without coupling the code to their classes. All shape classes (Rectangle and Circle) follow the same interface (Shape), which provides a cloning method. A subclass may call the parent’s cloning method before copying its own field values to the resulting object."},
	"Singleton":{"description":"Singleton lets you ensure that a class has only one instance, while providing a global access point to this instance.Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.","example":"Example: The database connection class acts as a Singleton. This class doesn’t have a public constructor (Database()), so the only way to get its object is to call the getInstance() method. This method caches the first created object and returns it in all subsequent calls."},
	"Adapter":{"description":"Adapter allows objects with incompatible interfaces to collaborate. Τhe adapter implements the interface of one object and wraps the other one.","example":"Example: Consider the case that you have a SquarePeg and you need to fit it in a RoundHole. You need to create an adapter, which receives calls from the client (RoundHole) via the adapter interface (RoundPeg) and translates them into calls to the wrapped service object (SquarePeg) in a format it can understand"},
	"Bridge":{"description":"Bridge lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.","example":"Example: Consider a case that you need to remotely control more than one device. Instead of creating a different class for controlling every device, you can create a bridge between Remote (Abstraction) and Device (Implementation), which allows you to hande many devices by the Device interface."},
	"Composite":{"description":"Composite lets you compose objects into tree structures and then work with these structures as if they were individual objects.","example":"Example: Consider the case that you need to draw an image consisted of dots or circles.  A compound shape (CompoundGraphic) passes the request recursively to all its children and “sums up” the result."},
	"Decorator":{"description":"Decorator lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.","example":"Example: The application wraps the data source object (FileDataSource) with a pair of decorators (EncryptionDecorator and CompressionDecorator). Both wrappers change the way the data is written to and read from the disk. Just before the data is written to disk, the decorators encrypt and compress it. Right after the data is read from disk, it goes through the same decorators, which decompress and decode it. "},
	"Facade":{"description":"Facade is a simplified interface to a library, a framework, or any other complex set of classes(complex subsystem) and provides only the features that the client cares about.","example":"Example: Consider a case you want your code to interact with a complex video conversion framework. A facade class encapsulates that functionality and hides it from the rest of the code."},
	"Flyweight":{"description":"","example":""},
	"Proxy":{"description":"","example":""},
	"ChainofResponsibility":{},
	"Command":{"description":"","example":""},
	"Interpeter":{"description":"","example":""},
	"Iterator":{"description":"","example":""},
	"Mediator":{"description":"","example":""},
	"Memento":{"description":"","example":""},
	"Observer":{"description":"","example":""},
	"State":{"description":"","example":""},
	"Strategy":{"description":"","example":""},
	"TemplateMethod":{"description":"","example":""},
	"Visitor":{"description":"","example":""}
}